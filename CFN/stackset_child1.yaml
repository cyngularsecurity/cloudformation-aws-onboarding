AWSTemplateFormatVersion: 2010-09-09
Description: >-
  StackSet - 1
  Applied on all client accounts in one region

Parameters:
  ClientName:
    Description: The name of the client
    Type: String
  CyngularAccountId:
    Description: The cyngular account id
    Type: String
  S3BucketArn:
    Description: The Arn of the S3 Bucket.
    Type: String
  ClientRegions:
    Description: The regions in which the client operate (use whitespace)
    Type: String
  EnableDNS:
    Description: "DNS Service - Whether to Create Route 53 Resolver, for vpc flows logs"
    Type: String
  EnableEKS:
    Description: "EKS Service - Whether to Configure EKS Audit & authenticator Logging for kubernetes Clusters"
    Type: String
  EnableVPCFlowLogs:
    Description: "EKS Service - Whether to Configure EKS Audit & authenticator Logging for kubernetes Clusters"
    Type: String

Conditions:
  ServiceDNS: !Equals [ !Ref EnableDNS, "true" ]
  ServiceEKS: !Equals [ !Ref EnableEKS, "true" ]
  ServiceVFL: !Equals [ !Ref EnableVPCFlowLogs, "true" ]

Resources:
  ClientCyngularRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "cyngular-readonly-role-${ClientName}"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${CyngularAccountId}:root"
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: cyngular-readonly-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: readOnly
                Effect: Allow
                Resource: '*'
                Action:
                  - iam:List*
                  - iam:Get*
                  - iam:GenerateServiceLastAccessedDetails

                  - organizations:Describe*
                  - organizations:List*
                  - organizations:EnableAWSServiceAccess
                  - organizations:RegisterDelegatedAdministrator

                  - ce:GetCostAndUsage
                  - ce:GetDimensionValues

                  - s3:List*
                  - s3:Describe*
                  - s3:GetBucketAcl
                  - s3:GetBucketLocation
                  - s3:GetBucketPolicyStatus
                  - s3:GetEncryptionConfiguration

                  - s3:GetAccountPublicAccessBlock
                  - s3:GetBucketPublicAccessBlock

                  - logs:List*
                  - logs:Describe*
                  - logs:Get*
                  - logs:FilterLogEvents
                  - logs:StartQuery
                  - cloudwatch:GetMetricStatistics

                  - ec2:List*
                  - ec2:CreateTags
                  - ec2:Describe*
                  - ec2:GetImageBlockPublicAccessState
                  - ecr:Describe*
                  - ecr:List*
                  - eks:Describe*
                  - eks:List*
                  - ecs:List*
                  - ecs:Describe*
                  - lambda:List*
                  - lambda:Get*
                  - rds:List*
                  - rds:Describe*

                  # CFN Stacks
                  - cloudformation:Describe*
                  - cloudformation:List*
                  - cloudformation:Get*
                  
                  - tag:GetResources

                  # Route 53
                  - 'route53:Get*'
                  - 'route53:List*'
                  - 'route53:TestDNSAnswer'
                  # CloudTrail
                  - 'cloudtrail:GetTrail'
                  - 'cloudtrail:DescribeTrails'
                  - 'cloudtrail:GetTrailStatus'
                  - 'cloudtrail:LookupEvents'
                  - 'cloudtrail:ListTags'
                  - 'cloudtrail:ListTrails'
                  - 'cloudtrail:GetEventSelectors'
                  - 'cloudtrail:GetInsightSelectors'
                  # KMS
                  - 'kms:Describe*'
                  - 'kms:Get*'
                  - 'kms:List*'
                  # Event Bridge
                  - "events:ListRules"
                  - "events:ListTargetsByRule"
                  - "events:ListEventBuses"
                  - "events:DescribeEventBus"
                  - "events:DescribeRule"
                  - "events:TestEventPattern"
                  - "events:PutRule"
                  - "events:PutTargets"

              - Sid: ec2CyngularSnapshot
                Effect: Allow
                Action:
                  - ec2:DeleteSnapshot
                  - ec2:ModifySnapshotAttribute
                Resource: '*'
                Condition:
                  StringLike:
                    aws:ResourceTag/Name: cyngular*
              - Sid: ec2CreateSnapshot
                Effect: Allow
                Resource: '*'
                Action:
                  - ec2:CopySnapshot
                  - ec2:CreateSnapshot
                  - ec2:CreateSnapshots
              - Sid: CyngularBucketAdmin
                Effect: Allow
                Resource:
                  - !Ref S3BucketArn
                  - !Sub "${S3BucketArn}/*"
                Action: "s3:*"
              - Sid: KmsPartial
                Effect: Allow
                Resource: '*'
                Action:
                  - kms:Decrypt
                  - kms:CreateGrant
              - Sid: CyngularKmsKey
                Effect: Allow
                Resource: '*'
                Action: "kms:*"
                Condition:
                  StringLike:
                    aws:ResourceTag/Name: cyngular*

  LambdasRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "cyngular-lambdas-role-${ClientName}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: cyngular-lambdas-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: first
                Effect: Allow
                Resource: '*'
                Action:
                  - route53resolver:*
                  - organizations:ListAccounts
                  - ec2:Describe*
                  - ec2:CreateFlowLogs
                  - ec2:DeleteFlowLogs
                  - ec2:CreateTags
                  - ec2:DeleteTags
                  - ssm:*
                  - logs:*
                  - eks:List*
                  - eks:UpdateClusterConfig
                  - events:PutRule
                  - events:DisableRule
                  - lambda:InvokeFunction
                  - lambda:UpdateFunctionConfiguration

              - Sid: EditEKS
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:eks:*:${AWS::AccountId}:cluster/*"
                  - !Sub "arn:aws:eks:*:${AWS::AccountId}:access-entry/*/role/${AWS::AccountId}/cyngular-readonly-role-${ClientName}/*"
                Action:
                  - "eks:CreateAccessEntry"
                  - "eks:AssociateAccessPolicy"
                  - "eks:DescribeCluster"

  LambdaOS:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "cyngular-lambda-config-os"
      Description: "Created by Cyngular Security | Configure OS Service"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Ref ClientRegions
          FINAL_CRON: "cron(0 0 * * ? *)"
          FIRST_RUN: "true"

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 300
      Code:
        ZipFile: |
            import boto3
            import traceback
            import os
            import logging

            def osinternals(curr_region):
                try:
                    logging.info('STARTING OS INTERNALS...')
                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    ssm_client = boto3.client('ssm', region_name=curr_region
                    )

                    all_instances = ec2_client.describe_instances()
                    instance_ids = []
                    for reservation in all_instances['Reservations']:
                        for instance in reservation['Instances']:
                            instance_ids.append(instance['InstanceId'])

                    auditd_rules = 'IyAgICAgIF9fXyAgICAgICAgICAgICBfX18gX18gICAgICBfXwojICAgICAvICAgfCBfXyAgX19fX19fLyAoXykgL19fX19fLyAvCiMgICAgLyAvfCB8LyAvIC8gLyBfXyAgLyAvIF9fLyBfXyAgLwojICAgLyBfX18gLyAvXy8gLyAvXy8gLyAvIC9fLyAvXy8gLwojICAvXy8gIHxfXF9fLF8vXF9fLF8vXy9cX18vXF9fLF8vCiMKIyBMaW51eCBBdWRpdCBEYWVtb24gLSBCZXN0IFByYWN0aWNlIENvbmZpZ3VyYXRpb24KIyAvZXRjL2F1ZGl0L2F1ZGl0LnJ1bGVzCiMKIyBDb21waWxlZCBieSBDeW5ndWxhciBTZWN1cml0eQojCgojIFJlbW92ZSBhbnkgZXhpc3RpbmcgcnVsZXMKLUQKCiMgQnVmZmVyIFNpemUKIyMgRmVlbCBmcmVlIHRvIGluY3JlYXNlIHRoaXMgaWYgdGhlIG1hY2hpbmUgcGFuaWMncwotYiA4MTkyCgojIEZhaWx1cmUgTW9kZQojIyBQb3NzaWJsZSB2YWx1ZXM6IDAgKHNpbGVudCksIDEgKHByaW50aywgcHJpbnQgYSBmYWlsdXJlIG1lc3NhZ2UpLCAyIChwYW5pYywgaGFsdCB0aGUgc3lzdGVtKQotZiAxCgojIElnbm9yZSBlcnJvcnMKIyMgZS5nLiBjYXVzZWQgYnkgdXNlcnMgb3IgZmlsZXMgbm90IGZvdW5kIGluIHRoZSBsb2NhbCBlbnZpcm9ubWVudAotaQoKIyBTZWxmIEF1ZGl0aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMgQXVkaXQgdGhlIGF1ZGl0IGxvZ3MKIyMjIFN1Y2Nlc3NmdWwgYW5kIHVuc3VjY2Vzc2Z1bCBhdHRlbXB0cyB0byByZWFkIGluZm9ybWF0aW9uIGZyb20gdGhlIGF1ZGl0IHJlY29yZHMKLXcgL3Zhci9sb2cvYXVkaXQvIC1rIGF1ZGl0bG9nCgojIyBBdWRpdGQgY29uZmlndXJhdGlvbgojIyMgTW9kaWZpY2F0aW9ucyB0byBhdWRpdCBjb25maWd1cmF0aW9uIHRoYXQgb2NjdXIgd2hpbGUgdGhlIGF1ZGl0IGNvbGxlY3Rpb24gZnVuY3Rpb25zIGFyZSBvcGVyYXRpbmcKLXcgL2V0Yy9hdWRpdC8gLXAgd2EgLWsgYXVkaXRjb25maWcKLXcgL2V0Yy9saWJhdWRpdC5jb25mIC1wIHdhIC1rIGF1ZGl0Y29uZmlnCi13IC9ldGMvYXVkaXNwLyAtcCB3YSAtayBhdWRpc3Bjb25maWcKCiMjIE1vbml0b3IgZm9yIHVzZSBvZiBhdWRpdCBtYW5hZ2VtZW50IHRvb2xzCi13IC9zYmluL2F1ZGl0Y3RsIC1wIHggLWsgYXVkaXR0b29scwotdyAvc2Jpbi9hdWRpdGQgLXAgeCAtayBhdWRpdHRvb2xzCi13IC91c3Ivc2Jpbi9hdWdlbnJ1bGVzIC1wIHggLWsgYXVkaXR0b29scwoKIyBGaWx0ZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMjIFdlIHB1dCB0aGVzZSBlYXJseSBiZWNhdXNlIGF1ZGl0IGlzIGEgZmlyc3QgbWF0Y2ggd2lucyBzeXN0ZW0uCgojIyBleGNsdWRlcwotYSBuZXZlcixleGl0IC1GIGV4ZT0vdXNyL3NiaW4vY3JvbiAtayBleGNsdWRlX2Nyb24KLWEgbmV2ZXIsZXhpdCAtRiBleGU9L3Vzci9iaW4vZHBrZyAtayBleGNsdWRlX2Rwa2cKCiMjIElnbm9yZSBTRUxpbnV4IEFWQyByZWNvcmRzCi1hIGFsd2F5cyxleGNsdWRlIC1GIG1zZ3R5cGU9QVZDCgojIyBJZ25vcmUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSByZWNvcmRzCi1hIGFsd2F5cyxleGNsdWRlIC1GIG1zZ3R5cGU9Q1dECgojIyBDcm9uIGpvYnMgZmlsbCB0aGUgbG9ncyB3aXRoIHN0dWZmIHdlIG5vcm1hbGx5IGRvbid0IHdhbnQgKHdvcmtzIHdpdGggU0VMaW51eCkKLWEgbmV2ZXIsdXNlciAtRiBzdWJqX3R5cGU9Y3JvbmRfdAotYSBuZXZlcixleGl0IC1GIHN1YmpfdHlwZT1jcm9uZF90CgojIyBUaGlzIHByZXZlbnRzIGNocm9ueSBmcm9tIG92ZXJ3aGVsbWluZyB0aGUgbG9ncwotYSBuZXZlcixleGl0IC1GIGFyY2g9YjY0IC1TIGFkanRpbWV4IC1GIGF1aWQ9dW5zZXQgLUYgdWlkPWNocm9ueSAtRiBzdWJqX3R5cGU9Y2hyb255ZF90CgojIyBUaGlzIGlzIG5vdCB2ZXJ5IGludGVyZXN0aW5nIGFuZCB3YXN0ZXMgYSBsb3Qgb2Ygc3BhY2UgaWYgdGhlIHNlcnZlciBpcyBwdWJsaWMgZmFjaW5nCi1hIGFsd2F5cyxleGNsdWRlIC1GIG1zZ3R5cGU9Q1JZUFRPX0tFWV9VU0VSCgojIyBWTVdhcmUgdG9vbHMKLWEgbmV2ZXIsZXhpdCAtRiBhcmNoPWIzMiAtUyBmb3JrIC1GIHN1Y2Nlc3M9MCAtRiBwYXRoPS91c3IvbGliL3Ztd2FyZS10b29scyAtRiBzdWJqX3R5cGU9aW5pdHJjX3QgLUYgZXhpdD0tMgotYSBuZXZlcixleGl0IC1GIGFyY2g9YjY0IC1TIGZvcmsgLUYgc3VjY2Vzcz0wIC1GIHBhdGg9L3Vzci9saWIvdm13YXJlLXRvb2xzIC1GIHN1YmpfdHlwZT1pbml0cmNfdCAtRiBleGl0PS0yCgojIyBIaWdoIFZvbHVtZSBFdmVudCBGaWx0ZXIgKGVzcGVjaWFsbHkgb24gTGludXggV29ya3N0YXRpb25zKQotYSBuZXZlcixleGl0IC1GIGFyY2g9YjMyIC1GIGRpcj0vZGV2L3NobSAtayBzaGFyZWRtZW1hY2Nlc3MKLWEgbmV2ZXIsZXhpdCAtRiBhcmNoPWI2NCAtRiBkaXI9L2Rldi9zaG0gLWsgc2hhcmVkbWVtYWNjZXNzCi1hIG5ldmVyLGV4aXQgLUYgYXJjaD1iMzIgLUYgZGlyPS92YXIvbG9jay9sdm0gLWsgbG9ja2x2bQotYSBuZXZlcixleGl0IC1GIGFyY2g9YjY0IC1GIGRpcj0vdmFyL2xvY2svbHZtIC1rIGxvY2tsdm0KCiMjIEZpbGVCZWF0IAotYSBuZXZlcixleGl0IC1GIGFyY2g9YjMyIC1GIHBhdGg9L29wdC9maWxlYmVhdCAtayBmaWxlYmVhdAotYSBuZXZlcixleGl0IC1GIGFyY2g9YjY0IC1GIHBhdGg9L29wdC9maWxlYmVhdCAtayBmaWxlYmVhdAoKIyMgTW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZmlsdGVyIGV2ZW50cwojIyMgaHR0cHM6Ly9hY2Nlc3MucmVkaGF0LmNvbS9zb2x1dGlvbnMvMjQ4MjIyMQoKIyBSdWxlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMgS2VybmVsIHBhcmFtZXRlcnMKLXcgL2V0Yy9zeXNjdGwuY29uZiAtcCB3YSAtayBzeXNjdGwKLXcgL2V0Yy9zeXNjdGwuZCAtcCB3YSAtayBzeXNjdGwKCiMjIEtlcm5lbCBtb2R1bGUgbG9hZGluZyBhbmQgdW5sb2FkaW5nCi1hIGFsd2F5cyxleGl0IC1GIHBlcm09eCAtRiBhdWlkIT0tMSAtRiBwYXRoPS9zYmluL2luc21vZCAtayBtb2R1bGVzCi1hIGFsd2F5cyxleGl0IC1GIHBlcm09eCAtRiBhdWlkIT0tMSAtRiBwYXRoPS9zYmluL21vZHByb2JlIC1rIG1vZHVsZXMKLWEgYWx3YXlzLGV4aXQgLUYgcGVybT14IC1GIGF1aWQhPS0xIC1GIHBhdGg9L3NiaW4vcm1tb2QgLWsgbW9kdWxlcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBmaW5pdF9tb2R1bGUgLVMgaW5pdF9tb2R1bGUgLVMgZGVsZXRlX21vZHVsZSAtRiBhdWlkIT0tMSAtayBtb2R1bGVzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGZpbml0X21vZHVsZSAtUyBpbml0X21vZHVsZSAtUyBkZWxldGVfbW9kdWxlIC1GIGF1aWQhPS0xIC1rIG1vZHVsZXMKCiMjIE1vZHByb2JlIGNvbmZpZ3VyYXRpb24KLXcgL2V0Yy9tb2Rwcm9iZS5jb25mIC1wIHdhIC1rIG1vZHByb2JlCi13IC9ldGMvbW9kcHJvYmUuZCAtcCB3YSAtayBtb2Rwcm9iZQoKIyMgS0V4ZWMgdXNhZ2UgKGFsbCBhY3Rpb25zKQotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBrZXhlY19sb2FkIC1rIEtFWEVDCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHN5c19rZXhlY19sb2FkIC1rIEtFWEVDCgojIyBTcGVjaWFsIGZpbGVzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIG1rbm9kIC1TIG1rbm9kYXQgLWsgc3BlY2lhbGZpbGVzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIG1rbm9kIC1TIG1rbm9kYXQgLWsgc3BlY2lhbGZpbGVzCgojIyBNb3VudCBvcGVyYXRpb25zIChvbmx5IGF0dHJpYnV0YWJsZSkKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgbW91bnQgLVMgdW1vdW50MiAtRiBhdWlkIT0tMSAtayBtb3VudAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBtb3VudCAtUyB1bW91bnQgLVMgdW1vdW50MiAtRiBhdWlkIT0tMSAtayBtb3VudAoKIyMgQ2hhbmdlIHN3YXAgKG9ubHkgYXR0cmlidXRhYmxlKQotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBzd2Fwb24gLVMgc3dhcG9mZiAtRiBhdWlkIT0tMSAtayBzd2FwCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHN3YXBvbiAtUyBzd2Fwb2ZmIC1GIGF1aWQhPS0xIC1rIHN3YXAKCiMjIFRpbWUKIy1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1GIHVpZCE9bnRwIC1TIGFkanRpbWV4IC1TIHNldHRpbWVvZmRheSAtUyBjbG9ja19zZXR0aW1lIC1rIHRpbWUKIy1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1GIHVpZCE9bnRwIC1TIGFkanRpbWV4IC1TIHNldHRpbWVvZmRheSAtUyBjbG9ja19zZXR0aW1lIC1rIHRpbWUKIyMjIExvY2FsIHRpbWUgem9uZQojLXcgL2V0Yy9sb2NhbHRpbWUgLXAgd2EgLWsgbG9jYWx0aW1lCgojIyBTdHVubmVsCi13IC91c3Ivc2Jpbi9zdHVubmVsIC1wIHggLWsgc3R1bm5lbAotdyAvdXNyL2Jpbi9zdHVubmVsIC1wIHggLWsgc3R1bm5lbAoKIyMgQ3JvbiBjb25maWd1cmF0aW9uICYgc2NoZWR1bGVkIGpvYnMKLXcgL2V0Yy9jcm9uLmFsbG93IC1wIHdhIC1rIGNyb24KLXcgL2V0Yy9jcm9uLmRlbnkgLXAgd2EgLWsgY3JvbgotdyAvZXRjL2Nyb24uZC8gLXAgd2EgLWsgY3JvbgotdyAvZXRjL2Nyb24uZGFpbHkvIC1wIHdhIC1rIGNyb24KLXcgL2V0Yy9jcm9uLmhvdXJseS8gLXAgd2EgLWsgY3JvbgotdyAvZXRjL2Nyb24ubW9udGhseS8gLXAgd2EgLWsgY3JvbgotdyAvZXRjL2Nyb24ud2Vla2x5LyAtcCB3YSAtayBjcm9uCi13IC9ldGMvY3JvbnRhYiAtcCB3YSAtayBjcm9uCi13IC92YXIvc3Bvb2wvY3Jvbi8gLWsgY3JvbgoKIyMgVXNlciwgZ3JvdXAsIHBhc3N3b3JkIGRhdGFiYXNlcwotdyAvZXRjL2dyb3VwIC1wIHdhIC1rIGV0Y2dyb3VwCi13IC9ldGMvcGFzc3dkIC1wIHdhIC1rIGV0Y3Bhc3N3ZAotdyAvZXRjL2dzaGFkb3cgLWsgZXRjZ3JvdXAKLXcgL2V0Yy9zaGFkb3cgLWsgZXRjcGFzc3dkCi13IC9ldGMvc2VjdXJpdHkvb3Bhc3N3ZCAtayBvcGFzc3dkCgojIyBTdWRvZXJzIGZpbGUgY2hhbmdlcwotdyAvZXRjL3N1ZG9lcnMgLXAgd2EgLWsgYWN0aW9ucwotdyAvZXRjL3N1ZG9lcnMuZC8gLXAgd2EgLWsgYWN0aW9ucwoKIyMgUGFzc3dkCi13IC91c3IvYmluL3Bhc3N3ZCAtcCB4IC1rIHBhc3N3ZF9tb2RpZmljYXRpb24KCiMjIFRvb2xzIHRvIGNoYW5nZSBncm91cCBpZGVudGlmaWVycwotdyAvdXNyL3NiaW4vZ3JvdXBhZGQgLXAgeCAtayBncm91cF9tb2RpZmljYXRpb24KLXcgL3Vzci9zYmluL2dyb3VwbW9kIC1wIHggLWsgZ3JvdXBfbW9kaWZpY2F0aW9uCi13IC91c3Ivc2Jpbi9hZGRncm91cCAtcCB4IC1rIGdyb3VwX21vZGlmaWNhdGlvbgotdyAvdXNyL3NiaW4vdXNlcmFkZCAtcCB4IC1rIHVzZXJfbW9kaWZpY2F0aW9uCi13IC91c3Ivc2Jpbi91c2VyZGVsIC1wIHggLWsgdXNlcl9tb2RpZmljYXRpb24KLXcgL3Vzci9zYmluL3VzZXJtb2QgLXAgeCAtayB1c2VyX21vZGlmaWNhdGlvbgotdyAvdXNyL3NiaW4vYWRkdXNlciAtcCB4IC1rIHVzZXJfbW9kaWZpY2F0aW9uCgojIyBMb2dpbiBjb25maWd1cmF0aW9uIGFuZCBpbmZvcm1hdGlvbgotdyAvZXRjL2xvZ2luLmRlZnMgLXAgd2EgLWsgbG9naW4KLXcgL2V0Yy9zZWN1cmV0dHkgLXAgd2EgLWsgbG9naW4KLXcgL3Zhci9sb2cvZmFpbGxvZyAtcCB3YSAtayBsb2dpbgotdyAvdmFyL2xvZy9sYXN0bG9nIC1wIHdhIC1rIGxvZ2luCi13IC92YXIvbG9nL3RhbGx5bG9nIC1wIHdhIC1rIGxvZ2luCgojIyBOZXR3b3JrIEVudmlyb25tZW50CiMjIyBDaGFuZ2VzIHRvIGhvc3RuYW1lCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHNldGhvc3RuYW1lIC1TIHNldGRvbWFpbm5hbWUgLWsgbmV0d29ya19tb2RpZmljYXRpb25zCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHNldGhvc3RuYW1lIC1TIHNldGRvbWFpbm5hbWUgLWsgbmV0d29ya19tb2RpZmljYXRpb25zCgojIyMgU3VjY2Vzc2Z1bCBJUHY0IENvbm5lY3Rpb25zCiMtYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBjb25uZWN0IC1GIGEyPTE2IC1GIHN1Y2Nlc3M9MSAtRiBrZXk9bmV0d29ya19jb25uZWN0XzQKIy1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGNvbm5lY3QgLUYgYTI9MTYgLUYgc3VjY2Vzcz0xIC1GIGtleT1uZXR3b3JrX2Nvbm5lY3RfNAoKIyMjIFN1Y2Nlc3NmdWwgSVB2NiBDb25uZWN0aW9ucwojLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgY29ubmVjdCAtRiBhMj0yOCAtRiBzdWNjZXNzPTEgLUYga2V5PW5ldHdvcmtfY29ubmVjdF82CiMtYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBjb25uZWN0IC1GIGEyPTI4IC1GIHN1Y2Nlc3M9MSAtRiBrZXk9bmV0d29ya19jb25uZWN0XzYKCiMjIyBDaGFuZ2VzIHRvIG90aGVyIGZpbGVzCi13IC9ldGMvaG9zdHMgLXAgd2EgLWsgbmV0d29ya19tb2RpZmljYXRpb25zCi13IC9ldGMvc3lzY29uZmlnL25ldHdvcmsgLXAgd2EgLWsgbmV0d29ya19tb2RpZmljYXRpb25zCi13IC9ldGMvc3lzY29uZmlnL25ldHdvcmstc2NyaXB0cyAtcCB3IC1rIG5ldHdvcmtfbW9kaWZpY2F0aW9ucwotdyAvZXRjL25ldHdvcmsvIC1wIHdhIC1rIG5ldHdvcmsKLWEgYWx3YXlzLGV4aXQgLUYgZGlyPS9ldGMvTmV0d29ya01hbmFnZXIvIC1GIHBlcm09d2EgLWsgbmV0d29ya19tb2RpZmljYXRpb25zCgojIyMgQ2hhbmdlcyB0byBpc3N1ZQotdyAvZXRjL2lzc3VlIC1wIHdhIC1rIGV0Y2lzc3VlCi13IC9ldGMvaXNzdWUubmV0IC1wIHdhIC1rIGV0Y2lzc3VlCgojIyBTeXN0ZW0gc3RhcnR1cCBzY3JpcHRzCi13IC9ldGMvaW5pdHRhYiAtcCB3YSAtayBpbml0Ci13IC9ldGMvaW5pdC5kLyAtcCB3YSAtayBpbml0Ci13IC9ldGMvaW5pdC8gLXAgd2EgLWsgaW5pdAoKIyMgTGlicmFyeSBzZWFyY2ggcGF0aHMKLXcgL2V0Yy9sZC5zby5jb25mIC1wIHdhIC1rIGxpYnBhdGgKLXcgL2V0Yy9sZC5zby5jb25mLmQgLXAgd2EgLWsgbGlicGF0aAoKIyMgU3lzdGVtd2lkZSBsaWJyYXJ5IHByZWxvYWRzIChMRF9QUkVMT0FEKQotdyAvZXRjL2xkLnNvLnByZWxvYWQgLXAgd2EgLWsgc3lzdGVtd2lkZV9wcmVsb2FkcwoKIyMgUGFtIGNvbmZpZ3VyYXRpb24KLXcgL2V0Yy9wYW0uZC8gLXAgd2EgLWsgcGFtCi13IC9ldGMvc2VjdXJpdHkvbGltaXRzLmNvbmYgLXAgd2EgIC1rIHBhbQotdyAvZXRjL3NlY3VyaXR5L2xpbWl0cy5kIC1wIHdhICAtayBwYW0KLXcgL2V0Yy9zZWN1cml0eS9wYW1fZW52LmNvbmYgLXAgd2EgLWsgcGFtCi13IC9ldGMvc2VjdXJpdHkvbmFtZXNwYWNlLmNvbmYgLXAgd2EgLWsgcGFtCi13IC9ldGMvc2VjdXJpdHkvbmFtZXNwYWNlLmQgLXAgd2EgLWsgcGFtCi13IC9ldGMvc2VjdXJpdHkvbmFtZXNwYWNlLmluaXQgLXAgd2EgLWsgcGFtCgojIyBNYWlsIGNvbmZpZ3VyYXRpb24KIy13IC9ldGMvYWxpYXNlcyAtcCB3YSAtayBtYWlsCiMtdyAvZXRjL3Bvc3RmaXgvIC1wIHdhIC1rIG1haWwKIy13IC9ldGMvZXhpbTQvIC1wIHdhIC1rIG1haWwKCiMjIFNTSCBjb25maWd1cmF0aW9uCi13IC9ldGMvc3NoL3NzaGRfY29uZmlnIC1rIHNzaGQKLXcgL2V0Yy9zc2gvc3NoZF9jb25maWcuZCAtayBzc2hkCgojIyByb290IHNzaCBrZXkgdGFtcGVyaW5nCi13IC9yb290Ly5zc2ggLXAgd2EgLWsgcm9vdGtleQoKIyBTeXN0ZW1kCi13IC9iaW4vc3lzdGVtY3RsIC1wIHggLWsgc3lzdGVtZAotdyAvZXRjL3N5c3RlbWQvIC1wIHdhIC1rIHN5c3RlbWQKCiMjIFNFTGludXggZXZlbnRzIHRoYXQgbW9kaWZ5IHRoZSBzeXN0ZW0ncyBNYW5kYXRvcnkgQWNjZXNzIENvbnRyb2xzIChNQUMpCi13IC9ldGMvc2VsaW51eC8gLXAgd2EgLWsgbWFjX3BvbGljeQoKIyMgQ3JpdGljYWwgZWxlbWVudHMgYWNjZXNzIGZhaWx1cmVzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIG9wZW4gLUYgZGlyPS9ldGMgLUYgc3VjY2Vzcz0wIC1rIHVuYXV0aGVkZmlsZWFjY2VzcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBvcGVuIC1GIGRpcj0vYmluIC1GIHN1Y2Nlc3M9MCAtayB1bmF1dGhlZGZpbGVhY2Nlc3MKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgb3BlbiAtRiBkaXI9L3NiaW4gLUYgc3VjY2Vzcz0wIC1rIHVuYXV0aGVkZmlsZWFjY2VzcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBvcGVuIC1GIGRpcj0vdXNyL2JpbiAtRiBzdWNjZXNzPTAgLWsgdW5hdXRoZWRmaWxlYWNjZXNzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIG9wZW4gLUYgZGlyPS91c3Ivc2JpbiAtRiBzdWNjZXNzPTAgLWsgdW5hdXRoZWRmaWxlYWNjZXNzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIG9wZW4gLUYgZGlyPS92YXIgLUYgc3VjY2Vzcz0wIC1rIHVuYXV0aGVkZmlsZWFjY2VzcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBvcGVuIC1GIGRpcj0vaG9tZSAtRiBzdWNjZXNzPTAgLWsgdW5hdXRoZWRmaWxlYWNjZXNzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIG9wZW4gLUYgZGlyPS9zcnYgLUYgc3VjY2Vzcz0wIC1rIHVuYXV0aGVkZmlsZWFjY2VzcwoKIyMgUHJvY2VzcyBJRCBjaGFuZ2UgKHN3aXRjaGluZyBhY2NvdW50cykgYXBwbGljYXRpb25zCi13IC9iaW4vc3UgLXAgeCAtayBwcml2X2VzYwotdyAvdXNyL2Jpbi9zdWRvIC1wIHggLWsgcHJpdl9lc2MKLXcgL2V0Yy9zdWRvZXJzIC1wIHJ3IC1rIHByaXZfZXNjCi13IC9ldGMvc3Vkb2Vycy5kIC1wIHJ3IC1rIHByaXZfZXNjCgojIyBQb3dlciBzdGF0ZQotdyAvc2Jpbi9zaHV0ZG93biAtcCB4IC1rIHBvd2VyCi13IC9zYmluL3Bvd2Vyb2ZmIC1wIHggLWsgcG93ZXIKLXcgL3NiaW4vcmVib290IC1wIHggLWsgcG93ZXIKLXcgL3NiaW4vaGFsdCAtcCB4IC1rIHBvd2VyCgojIyBTZXNzaW9uIGluaXRpYXRpb24gaW5mb3JtYXRpb24KLXcgL3Zhci9ydW4vdXRtcCAtcCB3YSAtayBzZXNzaW9uCi13IC92YXIvbG9nL2J0bXAgLXAgd2EgLWsgc2Vzc2lvbgotdyAvdmFyL2xvZy93dG1wIC1wIHdhIC1rIHNlc3Npb24KCiMjIERpc2NyZXRpb25hcnkgQWNjZXNzIENvbnRyb2wgKERBQykgbW9kaWZpY2F0aW9ucwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBjaG1vZCAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGNob3duIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgZmNobW9kIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgZmNobW9kYXQgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBmY2hvd24gLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBmY2hvd25hdCAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGZyZW1vdmV4YXR0ciAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGZzZXR4YXR0ciAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGxjaG93biAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGxyZW1vdmV4YXR0ciAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGxzZXR4YXR0ciAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHJlbW92ZXhhdHRyIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgc2V0eGF0dHIgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBjaG1vZCAgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBjaG93biAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIGZjaG1vZCAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIGZjaG1vZGF0IC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgZmNob3duIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgZmNob3duYXQgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBmcmVtb3ZleGF0dHIgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBmc2V0eGF0dHIgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBsY2hvd24gLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBscmVtb3ZleGF0dHIgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBsc2V0eGF0dHIgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyByZW1vdmV4YXR0ciAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHNldHhhdHRyIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKCiMgU3BlY2lhbCBSdWxlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMjIFJlY29ubmFpc3NhbmNlCi13IC91c3IvYmluL3dob2FtaSAtcCB4IC1rIHJlY29uCi13IC91c3IvYmluL2lkIC1wIHggLWsgcmVjb24KLXcgL2Jpbi9ob3N0bmFtZSAtcCB4IC1rIHJlY29uCi13IC9iaW4vdW5hbWUgLXAgeCAtayByZWNvbgotdyAvZXRjL2lzc3VlIC1wIHIgLWsgcmVjb24KLXcgL2V0Yy9ob3N0bmFtZSAtcCByIC1rIHJlY29uCgojIyBTdXNwaWNpb3VzIGFjdGl2aXR5Ci13IC91c3IvYmluL3dnZXQgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL2N1cmwgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL2Jhc2U2NCAtcCB4IC1rIHN1c3BfYWN0aXZpdHkKLXcgL2Jpbi9uYyAtcCB4IC1rIHN1c3BfYWN0aXZpdHkKLXcgL2Jpbi9uZXRjYXQgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL25jYXQgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL3NzaCAtcCB4IC1rIHN1c3BfYWN0aXZpdHkKLXcgL3Vzci9iaW4vc2NwIC1wIHggLWsgc3VzcF9hY3Rpdml0eQotdyAvdXNyL2Jpbi9zZnRwIC1wIHggLWsgc3VzcF9hY3Rpdml0eQotdyAvdXNyL2Jpbi9mdHAgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL3NvY2F0IC1wIHggLWsgc3VzcF9hY3Rpdml0eQotdyAvdXNyL2Jpbi93aXJlc2hhcmsgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL3RzaGFyayAtcCB4IC1rIHN1c3BfYWN0aXZpdHkKLXcgL3Vzci9iaW4vcmF3c2hhcmsgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL3JkZXNrdG9wIC1wIHggLWsgc3VzcF9hY3Rpdml0eQotdyAvdXNyL2Jpbi9ubWFwIC1wIHggLWsgc3VzcF9hY3Rpdml0eQoKIyMgQWRkZWQgdG8gY2F0Y2ggbmV0Y2F0IG9uIFVidW50dQotdyAvYmluL25jLm9wZW5ic2QgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC9iaW4vbmMudHJhZGl0aW9uYWwgLXAgeCAtayBzdXNwX2FjdGl2aXR5CgojIyBTYmluIHN1c3BpY2lvdXMgYWN0aXZpdHkKLXcgL3NiaW4vaXB0YWJsZXMgLXAgeCAtayBzYmluX3N1c3AKLXcgL3NiaW4vaXA2dGFibGVzIC1wIHggLWsgc2Jpbl9zdXNwCi13IC9zYmluL2lmY29uZmlnIC1wIHggLWsgc2Jpbl9zdXNwCi13IC91c3Ivc2Jpbi9hcnB0YWJsZXMgLXAgeCAtayBzYmluX3N1c3AKLXcgL3Vzci9zYmluL2VidGFibGVzIC1wIHggLWsgc2Jpbl9zdXNwCi13IC9zYmluL3h0YWJsZXMtbmZ0LW11bHRpIC1wIHggLWsgc2Jpbl9zdXNwCi13IC91c3Ivc2Jpbi9uZnQgLXAgeCAtayBzYmluX3N1c3AKLXcgL3Vzci9zYmluL3RjcGR1bXAgLXAgeCAtayBzYmluX3N1c3AKLXcgL3Vzci9zYmluL3RyYWNlcm91dGUgLXAgeCAtayBzYmluX3N1c3AKLXcgL3Vzci9zYmluL3VmdyAtcCB4IC1rIHNiaW5fc3VzcAoKIyMgZGJ1cy1zZW5kIGludm9jYXRpb24KIyMjIG1heSBpbmRpY2F0ZSBwcml2aWxlZ2UgZXNjYWxhdGlvbiBDVkUtMjAyMS0zNTYwCi13IC91c3IvYmluL2RidXMtc2VuZCAtcCB4IC1rIGRidXNfc2VuZAoKIyMgcGtleGVjIGludm9jYXRpb24KIyMjIG1heSBpbmRpY2F0ZSBwcml2aWxlZ2UgZXNjYWxhdGlvbiBDVkUtMjAyMS00MDM0Ci13IC91c3IvYmluL3BrZXhlYyAtcCB4IC1rIHBrZXhlYwoKIyMgU3VzcGljaW91cyBzaGVsbHMKIy13IC9iaW4vYXNoIC1wIHggLWsgc3VzcF9zaGVsbAojLXcgL2Jpbi9iYXNoIC1wIHggLWsgc3VzcF9zaGVsbAojLXcgL2Jpbi9jc2ggLXAgeCAtayBzdXNwX3NoZWxsCiMtdyAvYmluL2Rhc2ggLXAgeCAtayBzdXNwX3NoZWxsCiMtdyAvYmluL2J1c3lib3ggLXAgeCAtayBzdXNwX3NoZWxsCiMtdyAvYmluL2tzaCAtcCB4IC1rIHN1c3Bfc2hlbGwKIy13IC9iaW4vZmlzaCAtcCB4IC1rIHN1c3Bfc2hlbGwKIy13IC9iaW4vdGNzaCAtcCB4IC1rIHN1c3Bfc2hlbGwKIy13IC9iaW4vdGNsc2ggLXAgeCAtayBzdXNwX3NoZWxsCiMtdyAvYmluL3pzaCAtcCB4IC1rIHN1c3Bfc2hlbGwKCiMjIFNoZWxsL3Byb2ZpbGUgY29uZmlndXJhdGlvbnMKLXcgL2V0Yy9wcm9maWxlLmQvIC1wIHdhIC1rIHNoZWxsX3Byb2ZpbGVzCi13IC9ldGMvcHJvZmlsZSAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwotdyAvZXRjL3NoZWxscyAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwotdyAvZXRjL2Jhc2hyYyAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwotdyAvZXRjL2NzaC5jc2hyYyAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwotdyAvZXRjL2NzaC5sb2dpbiAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwotdyAvZXRjL2Zpc2gvIC1wIHdhIC1rIHNoZWxsX3Byb2ZpbGVzCi13IC9ldGMvenNoLyAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwoKIyMgSW5qZWN0aW9uCiMjIyBUaGVzZSBydWxlcyB3YXRjaCBmb3IgY29kZSBpbmplY3Rpb24gYnkgdGhlIHB0cmFjZSBmYWNpbGl0eS4KIyMjIFRoaXMgY291bGQgaW5kaWNhdGUgc29tZW9uZSB0cnlpbmcgdG8gZG8gc29tZXRoaW5nIGJhZCBvciBqdXN0IGRlYnVnZ2luZwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBwdHJhY2UgLUYgYTA9MHg0IC1rIGNvZGVfaW5qZWN0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHB0cmFjZSAtRiBhMD0weDQgLWsgY29kZV9pbmplY3Rpb24KLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgcHRyYWNlIC1GIGEwPTB4NSAtayBkYXRhX2luamVjdGlvbgotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBwdHJhY2UgLUYgYTA9MHg1IC1rIGRhdGFfaW5qZWN0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHB0cmFjZSAtRiBhMD0weDYgLWsgcmVnaXN0ZXJfaW5qZWN0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHB0cmFjZSAtRiBhMD0weDYgLWsgcmVnaXN0ZXJfaW5qZWN0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHB0cmFjZSAtayB0cmFjaW5nCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHB0cmFjZSAtayB0cmFjaW5nCgojIyBBbm9ueW1vdXMgRmlsZSBDcmVhdGlvbgojIyMgVGhlc2UgcnVsZXMgd2F0Y2ggdGhlIHVzZSBvZiBtZW1mZF9jcmVhdGUgCiMjIyAibWVtZmRfY3JlYXRlIiBjcmVhdGVzIGFub255bW91cyBmaWxlIGFuZCByZXR1cm5zIGEgZmlsZSBkZXNjcmlwdG9yIHRvIGFjY2VzcyBpdAojIyMgV2hlbiBjb21iaW5lZCB3aXRoICJmZXhlY3ZlIiBjYW4gYmUgdXNlZCB0byBzdGVhbHRoaWx5IHJ1biBiaW5hcmllcyBpbiBtZW1vcnkgd2l0aG91dCB0b3VjaGluZyBkaXNrICAKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgbWVtZmRfY3JlYXRlIC1GIGtleT1hbm9uX2ZpbGVfY3JlYXRlCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIG1lbWZkX2NyZWF0ZSAtRiBrZXk9YW5vbl9maWxlX2NyZWF0ZSAgICAgIAoKCiMjIFByaXZpbGVnZSBBYnVzZQojIyMgVGhlIHB1cnBvc2Ugb2YgdGhpcyBydWxlIGlzIHRvIGRldGVjdCB3aGVuIGFuIGFkbWluIG1heSBiZSBhYnVzaW5nIHBvd2VyIGJ5IGxvb2tpbmcgaW4gdXNlcidzIGhvbWUgZGlyLgotYSBhbHdheXMsZXhpdCAtRiBkaXI9L2hvbWUgLUYgdWlkPTAgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtQyBhdWlkIT1vYmpfdWlkIC1rIHBvd2VyX2FidXNlCgojIFNvZnR3YXJlIE1hbmFnZW1lbnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIFJQTSAoUmVkaGF0L0NlbnRPUykKIy13IC91c3IvYmluL3JwbSAtcCB4IC1rIHNvZnR3YXJlX21nbXQKIy13IC91c3IvYmluL3l1bSAtcCB4IC1rIHNvZnR3YXJlX21nbXQKCiMgRE5GIChGZWRvcmEvUmVkSGF0IDgvQ2VudE9TIDgpCiMtdyAvdXNyL2Jpbi9kbmYgLXAgeCAtayBzb2Z0d2FyZV9tZ210CgojIFlBU1QvWnlwcGVyL1JQTSAoU3VTRSkKIy13IC9zYmluL3lhc3QgLXAgeCAtayBzb2Z0d2FyZV9tZ210CiMtdyAvc2Jpbi95YXN0MiAtcCB4IC1rIHNvZnR3YXJlX21nbXQKIy13IC9iaW4vcnBtIC1wIHggLWsgc29mdHdhcmVfbWdtdAojLXcgL3Vzci9iaW4venlwcGVyIC1rIHNvZnR3YXJlX21nbXQKCiMgRFBLRyAvIEFQVC1HRVQgKERlYmlhbi9VYnVudHUpCiMtdyAvdXNyL2Jpbi9kcGtnIC1wIHggLWsgc29mdHdhcmVfbWdtdAojLXcgL3Vzci9iaW4vYXB0IC1wIHggLWsgc29mdHdhcmVfbWdtdAojLXcgL3Vzci9iaW4vYXB0LWFkZC1yZXBvc2l0b3J5IC1wIHggLWsgc29mdHdhcmVfbWdtdAojLXcgL3Vzci9iaW4vYXB0LWdldCAtcCB4IC1rIHNvZnR3YXJlX21nbXQKIy13IC91c3IvYmluL2FwdGl0dWRlIC1wIHggLWsgc29mdHdhcmVfbWdtdAojLXcgL3Vzci9iaW4vd2FqaWcgLXAgeCAtayBzb2Z0d2FyZV9tZ210CiMtdyAvdXNyL2Jpbi9zbmFwIC1wIHggLWsgc29mdHdhcmVfbWdtdAoKIyBQSVAgKFB5dGhvbiBpbnN0YWxscykKIy13IC91c3IvYmluL3BpcCAtcCB4IC1rIHNvZnR3YXJlX21nbXQKIy13IC91c3IvYmluL3BpcDMgLXAgeCAtayBzb2Z0d2FyZV9tZ210CgojIFNwZWNpYWwgU29mdHdhcmUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIyBHRFMgc3BlY2lmaWMgc2VjcmV0cwotdyAvZXRjL3B1cHBldC9zc2wgLXAgd2EgLWsgcHVwcGV0X3NzbAoKIyMgSUJNIEJpZ2ZpeCBCRVNDbGllbnQKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgb3BlbiAtRiBkaXI9L29wdC9CRVNDbGllbnQgLUYgc3VjY2Vzcz0wIC1rIHNvZnRfYmVzY2xpZW50Ci13IC92YXIvb3B0L0JFU0NsaWVudC8gLXAgd2EgLWsgc29mdF9iZXNjbGllbnQKCiMjIENIRUYgaHR0cHM6Ly93d3cuY2hlZi5pby9jaGVmLwotdyAvZXRjL2NoZWYgLXAgd2EgLWsgc29mdF9jaGVmCgojIyBEb2NrZXIKIy13IC91c3IvYmluL2RvY2tlcmQgLWsgZG9ja2VyCiMtdyAvdXNyL2Jpbi9kb2NrZXIgLWsgZG9ja2VyCiMtdyAvdXNyL2Jpbi9kb2NrZXItY29udGFpbmVyZCAtayBkb2NrZXIKIy13IC91c3IvYmluL2RvY2tlci1ydW5jIC1rIGRvY2tlcgojLXcgL3Zhci9saWIvZG9ja2VyIC1rIGRvY2tlcgojLXcgL2V0Yy9kb2NrZXIgLWsgZG9ja2VyCiMtdyAvZXRjL3N5c2NvbmZpZy9kb2NrZXIgLWsgZG9ja2VyCiMtdyAvZXRjL3N5c2NvbmZpZy9kb2NrZXItc3RvcmFnZSAtayBkb2NrZXIKIy13IC91c3IvbGliL3N5c3RlbWQvc3lzdGVtL2RvY2tlci5zZXJ2aWNlIC1rIGRvY2tlcgoKIyMgS3ViZWxldAotdyAvdXNyL2Jpbi9rdWJlbGV0IC1rIGt1YmVsZXQKCiMgSGlnaCBWb2x1bWUgRXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMjIFJlbW92ZSB0aGVtIGlmIHRoZXkgY2F1c2UgdG8gbXVjaCB2b2x1bWUgaW4geW91ciBlbnZpcm9ubWVudAoKIyMgUm9vdCBjb21tYW5kIGV4ZWN1dGlvbnMKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLUYgZXVpZD0wIC1TIGV4ZWN2ZSAtayByb290Y21kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1GIGV1aWQ9MCAtUyBleGVjdmUgLWsgcm9vdGNtZAoKIyMgRmlsZSBEZWxldGlvbiBFdmVudHMgYnkgVXNlcgotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBybWRpciAtUyB1bmxpbmsgLVMgdW5saW5rYXQgLVMgcmVuYW1lIC1TIHJlbmFtZWF0IC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgZGVsZXRlCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHJtZGlyIC1TIHVubGluayAtUyB1bmxpbmthdCAtUyByZW5hbWUgLVMgcmVuYW1lYXQgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBkZWxldGUKCiMjIEZpbGUgQWNjZXNzCiMjIyBVbmF1dGhvcml6ZWQgQWNjZXNzICh1bnN1Y2Nlc3NmdWwpCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGNyZWF0IC1TIG9wZW4gLVMgb3BlbmF0IC1TIG9wZW5fYnlfaGFuZGxlX2F0IC1TIHRydW5jYXRlIC1TIGZ0cnVuY2F0ZSAtRiBleGl0PS1FQUNDRVMgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBmaWxlX2FjY2VzcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBjcmVhdCAtUyBvcGVuIC1TIG9wZW5hdCAtUyBvcGVuX2J5X2hhbmRsZV9hdCAtUyB0cnVuY2F0ZSAtUyBmdHJ1bmNhdGUgLUYgZXhpdD0tRVBFUk0gLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBmaWxlX2FjY2VzcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBjcmVhdCAtUyBvcGVuIC1TIG9wZW5hdCAtUyBvcGVuX2J5X2hhbmRsZV9hdCAtUyB0cnVuY2F0ZSAtUyBmdHJ1bmNhdGUgLUYgZXhpdD0tRUFDQ0VTIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgZmlsZV9hY2Nlc3MKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgY3JlYXQgLVMgb3BlbiAtUyBvcGVuYXQgLVMgb3Blbl9ieV9oYW5kbGVfYXQgLVMgdHJ1bmNhdGUgLVMgZnRydW5jYXRlIC1GIGV4aXQ9LUVQRVJNIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgZmlsZV9hY2Nlc3MKCiMjIyBVbnN1Y2Nlc3NmdWwgQ3JlYXRpb24KLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgY3JlYXQsbGluayxta25vZCxta2RpcixzeW1saW5rLG1rbm9kYXQsbGlua2F0LHN5bWxpbmthdCAtRiBleGl0PS1FQUNDRVMgLWsgZmlsZV9jcmVhdGlvbgotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBta2RpcixjcmVhdCxsaW5rLHN5bWxpbmssbWtub2QsbWtub2RhdCxsaW5rYXQsc3ltbGlua2F0IC1GIGV4aXQ9LUVBQ0NFUyAtayBmaWxlX2NyZWF0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGxpbmssbWtkaXIsc3ltbGluayxta2RpcmF0IC1GIGV4aXQ9LUVQRVJNIC1rIGZpbGVfY3JlYXRpb24KLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgbWtkaXIsbGluayxzeW1saW5rLG1rZGlyYXQgLUYgZXhpdD0tRVBFUk0gLWsgZmlsZV9jcmVhdGlvbgoKIyMjIFVuc3VjY2Vzc2Z1bCBNb2RpZmljYXRpb24KLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgcmVuYW1lIC1TIHJlbmFtZWF0IC1TIHRydW5jYXRlIC1TIGNobW9kIC1TIHNldHhhdHRyIC1TIGxzZXR4YXR0ciAtUyByZW1vdmV4YXR0ciAtUyBscmVtb3ZleGF0dHIgLUYgZXhpdD0tRUFDQ0VTIC1rIGZpbGVfbW9kaWZpY2F0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHJlbmFtZSAtUyByZW5hbWVhdCAtUyB0cnVuY2F0ZSAtUyBjaG1vZCAtUyBzZXR4YXR0ciAtUyBsc2V0eGF0dHIgLVMgcmVtb3ZleGF0dHIgLVMgbHJlbW92ZXhhdHRyIC1GIGV4aXQ9LUVBQ0NFUyAtayBmaWxlX21vZGlmaWNhdGlvbgotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyByZW5hbWUgLVMgcmVuYW1lYXQgLVMgdHJ1bmNhdGUgLVMgY2htb2QgLVMgc2V0eGF0dHIgLVMgbHNldHhhdHRyIC1TIHJlbW92ZXhhdHRyIC1TIGxyZW1vdmV4YXR0ciAtRiBleGl0PS1FUEVSTSAtayBmaWxlX21vZGlmaWNhdGlvbgotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyByZW5hbWUgLVMgcmVuYW1lYXQgLVMgdHJ1bmNhdGUgLVMgY2htb2QgLVMgc2V0eGF0dHIgLVMgbHNldHhhdHRyIC1TIHJlbW92ZXhhdHRyIC1TIGxyZW1vdmV4YXR0ciAtRiBleGl0PS1FUEVSTSAtayBmaWxlX21vZGlmaWNhdGlvbgoKIyMgMzJiaXQgQVBJIEV4cGxvaXRhdGlvbgojIyMgSWYgeW91IGFyZSBvbiBhIDY0IGJpdCBwbGF0Zm9ybSwgZXZlcnl0aGluZyBfc2hvdWxkXyBiZSBydW5uaW5nCiMjIyBpbiA2NCBiaXQgbW9kZS4gVGhpcyBydWxlIHdpbGwgZGV0ZWN0IGFueSB1c2Ugb2YgdGhlIDMyIGJpdCBzeXNjYWxscwojIyMgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGEgc2lnbiBvZiBzb21lb25lIGV4cGxvaXRpbmcgYSBob2xlIGluIHRoZSAzMgojIyMgYml0IEFQSS4KLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgYWxsIC1rIDMyYml0X2FwaQoKIyBNYWtlIFRoZSBDb25maWd1cmF0aW9uIEltbXV0YWJsZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMtZSAyCg=='
                    for instance_id in instance_ids:
                        try:
                            logging.info(f'CONFIGURING OS INTERNALS ON INSTANCE-ID: {instance_id}')
                            response = ssm_client.send_command(
                                InstanceIds=[instance_id],
                                DocumentName="AWS-RunShellScript",
                                Parameters={'commands': ['apt-get update -y','apt-get install -y auditd','systemctl kill auditd.service', 'sleep 10', f'echo {auditd_rules} | base64 --decode > "/etc/audit/rules.d/audit.rules"', 'sleep 10','systemctl start auditd.service'] }
                            )
                            logging.info(f'COMMAND SUCCEEDED.')
                        except Exception as e:
                            pass
                except Exception as e:
                    logging.critical(str(e))

            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger=logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STRATING CYNGULARS FUNCTION...')

                LAMBDA_NAME=context.function_name
                REGIONS=os.environ['CLIENT_REGIONS']
                try:
                    if os.environ.get('FIRST_RUN') == 'true':
                        logger.info('First run detected. Updating EventBridge rule schedule.')
                        try:
                            lambda_client=boto3.client('lambda')
                            events_client=boto3.client('events')
                            response=events_client.put_rule(
                                Name=f"{LAMBDA_NAME}-rule",
                                State='ENABLED',
                                ScheduleExpression=os.environ['FINAL_CRON'],
                                Description='LambdaOS | Config OS | Scheduled to run daily',
                                EventBusName='default'
                            )
                            logger.info('Successfully updated the EventBridge rule: %s', response)
                            response=lambda_client.update_function_configuration(
                                FunctionName=LAMBDA_NAME,
                                Environment={'Variables': {"FIRST_RUN": "false", "CLIENT_REGIONS": REGIONS}}
                            )
                            logger.info('Successfully updated the function configuration: %s', response)
                        except Exception as e:
                            logger.critical('Error updating the EventBridge rule: %s', str(e))
                            raise

                    for curr_region in REGIONS.split(','):
                        logger.info(f'Current AWS REGION: {curr_region}')
                        try:
                            osinternals(curr_region)
                        except Exception as e:
                            logger.critical(str(e))                  
                    logger.info('DONE!')

                except Exception as e:
                    logger.critical(str(e))

  ScheduledRuleLambdaOS: 
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub "${LambdaOS}-rule"
      Description: "Function did not run yet"
      ScheduleExpression: "rate(2 minutes)"
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaOS.Arn
          Id: "TargetFunctionV1"

  PermissionForEventsToInvokeLambdaOS: 
    Type: AWS::Lambda::Permission
    Properties: 
      FunctionName: !Ref LambdaOS
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt ScheduledRuleLambdaOS.Arn

  LambdaEKS:
    Type: AWS::Lambda::Function
    Condition: ServiceEKS
    Properties:
      FunctionName: "cyngular-lambda-config-eks"
      Description: "Created by Cyngular Security | Configure EKS Logging"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Ref ClientRegions
          FINAL_CRON: "cron(0 * * * ? *)"
          FIRST_RUN: "true"
          ROLE_ARN: !GetAtt ClientCyngularRole.Arn

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 300
      Code:
        ZipFile: |
            import boto3
            import traceback
            import os
            import logging
            from botocore.exceptions import ClientError

            def check_access_entry_exists(eks_client, cluster_name, role_arn):
                try:
                    response = eks_client.list_access_entries(clusterName=cluster_name)
                    if 'accessEntries' in response:
                        return role_arn in response['accessEntries']
                    return False
                except eks_client.exceptions.ResourceNotFoundException:
                    logging.error(f'Cluster {cluster_name} not found')
                    return False
                except ClientError as e:
                    if e.response['Error']['Code'] == 'InvalidRequestException' and 'authentication mode' in str(e):
                        logging.warning(f'Cluster {cluster_name} has incompatible authentication mode for access entries')
                        return False
                except Exception as e:
                    logging.error(f'Error checking access entries: {str(e)}')
                    return False

            def create_access_entry(eks_client, logger, cluster_name, role_arn):
                try:
                    try:
                        cluster_info = eks_client.describe_cluster(name=cluster_name)
                        auth_mode = cluster_info['cluster'].get('accessConfig', {}).get('authenticationMode', 'CONFIG_MAP')
                        if auth_mode not in ['API', 'API_AND_CONFIG_MAP']:
                            logger.warning(f'Skipping access entry creation for cluster {cluster_name} - incompatible authentication mode: {auth_mode}')
                            return
                    except Exception as e:
                        logger.error(f'Error checking cluster authentication mode: {str(e)}')
                        return

                    if check_access_entry_exists(eks_client, cluster_name, role_arn):
                        logger.info(f'Access entry for role {role_arn} already exists in cluster {cluster_name}.')
                        return

                    logger.info(f'Creating access entry for cluster: {cluster_name}')
                    response = eks_client.create_access_entry(
                        clusterName=cluster_name,
                        principalArn=role_arn,
                        type='STANDARD'
                    )
                    logger.info(f'Access entry created successfully: {response["accessEntry"]["accessEntryArn"]}')

                    logger.info(f'Associating access policy for cluster: {cluster_name}')
                    eks_client.associate_access_policy(
                        clusterName=cluster_name,
                        principalArn=role_arn,
                        policyArn='arn:aws:eks::aws:cluster-access-policy/AmazonEKSViewPolicy',
                        accessScope={
                            'type': 'cluster'
                        }
                    )
                    logger.info('Access policy associated successfully')
                except eks_client.exceptions.ResourceNotFoundException as e_not_found:
                    logger.error(f'Cluster {cluster_name} not found -- {str(e_not_found)}')
                except eks_client.exceptions.AccessDeniedException as e_access_denied:
                    logger.error(f'Access denied when creating access entry for cluster {cluster_name} -- {str(e_access_denied)}')
                except Exception as e:
                    logger.error(f'Error creating access entry: {str(e)}')

            def ekslogs(curr_region, logger, role_arn):
                try:
                    logger.info('STARTING EKSLOGS...')
                    wanted_cluster_logging_config = {
                        'clusterLogging': [{
                            'types': ['audit', 'authenticator'],
                            'enabled': True
                        }]
                    }
                    eks_client = boto3.client('eks', region_name=curr_region)
                    logger.info('EKS client created successfully')
                    
                    clusters = eks_client.list_clusters()['clusters']
                    logger.info(f'Found {len(clusters)} clusters in region {curr_region}')

                    for cluster_name in clusters:
                        try:
                            logger.info(f'CONFIGURING EKSLOGS ON CLUSTER: {cluster_name}')
                            eks_client.update_cluster_config(
                                name=cluster_name,
                                logging=wanted_cluster_logging_config
                            )
                            logger.info(f'COMMAND SUCCEEDED.')
                            
                        except Exception as e:
                            if 'No changes needed for the logging config provided' not in str(e):
                                logger.critical(f'COMMAND FAILED - {str(e)}')
                            else:
                                logger.info(f'No changes needed for cluster {cluster_name}')
                
                        create_access_entry(eks_client, logger, cluster_name, role_arn)

                except Exception as e:
                    logger.critical(f'Error in ekslogs function: {str(e)}')
                    logger.critical(traceback.format_exc())
                    
            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STARTING CYNGULARS FUNCTION...')

                LAMBDA_NAME = context.function_name
                REGIONS = os.environ['CLIENT_REGIONS']
                ROLE_ARN = os.environ['ROLE_ARN']
                try:
                    if os.environ.get('FIRST_RUN') == 'true':
                        logger.info('First run detected. Updating EventBridge rule schedule.')
                        try:
                            lambda_client = boto3.client('lambda')
                            events_client = boto3.client('events')
                            response = events_client.put_rule(
                                Name=f"{LAMBDA_NAME}-rule",
                                State='ENABLED',
                                ScheduleExpression=os.environ['FINAL_CRON'],
                                Description='LambdaEKS | Scheduled to run hourly',
                                EventBusName='default'
                            )
                            logger.info('Successfully updated the EventBridge rule: %s', response)
                            response = lambda_client.update_function_configuration(
                                FunctionName=LAMBDA_NAME,
                                Environment={'Variables': {"FIRST_RUN": "false", "CLIENT_REGIONS": REGIONS, "ROLE_ARN": ROLE_ARN}}
                            )
                            logger.info('Successfully updated the function configuration: %s', response)
                        except Exception as e:
                            logger.critical('Error updating the EventBridge rule: %s', str(e))
                            raise

                    logger.info('STARTING EKSLOGS...')                    
                    for curr_region in REGIONS.split(' '):
                        logger.info(f'AWS REGION: {curr_region}')
                        try:
                            ekslogs(curr_region, logger, ROLE_ARN)
                        except Exception as e:
                            logger.critical(str(e))
                    logger.info('DONE!')
                    return {
                        'statusCode': 200,
                        'body': 'Function executed successfully'
                    }

                except Exception as e:
                    logger.critical(str(e))
                    return {
                        'statusCode': 500,
                        'body': f'Error occurred: {str(e)}'
                    }


  ScheduledRuleLambdaEKS: 
    Type: AWS::Events::Rule
    Condition: ServiceEKS
    Properties:
      Name: !Sub "${LambdaEKS}-rule"
      Description: "Function did not run yet"
      ScheduleExpression: "rate(2 minutes)"
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaEKS.Arn
          Id: "TargetFunctionV1"

  PermissionForEventsToInvokeLambdaEKS: 
    Type: AWS::Lambda::Permission
    Condition: ServiceEKS
    Properties: 
      FunctionName: !Ref LambdaEKS
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt ScheduledRuleLambdaEKS.Arn

  LambdaDNS:
    Type: AWS::Lambda::Function
    Condition: ServiceDNS
    Properties:
      FunctionName: "cyngular-lambda-config-dns"
      Description: "Created by Cyngular Security. | Configure DNS"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Ref ClientRegions
          FINAL_CRON: "cron(0 * * * ? *)"
          FIRST_RUN: "true"

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 300
      Code:
        ZipFile: |
            import boto3
            import traceback
            import os
            import logging

            def dnslogs(curr_region):
                try:
                    logging.info(f'STARTING DNSLOGS...')
                    r_53_client = boto3.client('route53resolver', region_name=curr_region)
                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    
                    region_query_log_configs = r_53_client.list_resolver_query_log_configs()['ResolverQueryLogConfigs']
                    cyngular_resolver_id = ''
                    
                    for region_query_log_config in region_query_log_configs:
                        try:
                            if region_query_log_config['Name'] == 'cyngular_dns':
                                cyngular_resolver_id = region_query_log_config['Id']
                                break
                        except:
                            pass

                    if cyngular_resolver_id:
                        vpc_list = ec2_client.describe_vpcs()
                        if "Vpcs" in vpc_list:                  
                            for vpc in vpc_list["Vpcs"]:
                                try:
                                    vpc_id = vpc["VpcId"]
                                    logging.info(f'CONFIGURING DNSLOGS ON VPC-ID: {vpc_id}')
                                    resp = r_53_client.associate_resolver_query_log_config(ResolverQueryLogConfigId = cyngular_resolver_id, ResourceId = vpc_id )
                                    logging.info(f'COMMAND SUCCEEDED.')
                                except Exception as e:
                                    if 'already associated' in str(e):
                                        logging.critical(f'{vpc_id} - ResolverAlreadyAssociated')
                                    else:
                                        logging.critical(str(e))
                except Exception as e:
                    logging.critical(str(e))

            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STRATING CYNGULARS FUNCTION...')

                LAMBDA_NAME=context.function_name
                REGIONS=os.environ['CLIENT_REGIONS']
                try:
                    if os.environ.get('FIRST_RUN') == 'true':
                        logger.info('First run detected. Updating EventBridge rule schedule.')
                        try:
                            lambda_client = boto3.client('lambda')
                            events_client = boto3.client('events')
                            response = events_client.put_rule(
                                Name = f"{LAMBDA_NAME}-rule",
                                State = 'ENABLED',
                                ScheduleExpression = os.environ['FINAL_CRON'],
                                Description = 'LambdaDNS | Scheduled to run hourly',
                                EventBusName = 'default'
                            )
                            logger.info('Successfully updated the EventBridge rule: %s', response)
                            response = lambda_client.update_function_configuration(
                                FunctionName=LAMBDA_NAME,
                                Environment={'Variables': {"FIRST_RUN": "false", "CLIENT_REGIONS": REGIONS}}
                            )
                            logger.info('Successfully updated the function configuration: %s', response)
                        except Exception as e:
                            logger.error('Error updating the EventBridge rule: %s', str(e))
                            raise

                    logger.info('STARTING DNSLOGS...')                    
                    for curr_region in REGIONS.split(','):
                        logging.info(f'AWS REGION: {curr_region}')
                        try:
                            dnslogs(curr_region)
                        except Exception as e:
                            logging.critical(str(e))
                    logging.info('DONE!')

                except Exception as e:
                    logging.critical(str(e))

  ScheduledRuleLambdaDNS: 
    Type: AWS::Events::Rule
    Condition: ServiceDNS
    Properties:
      Name: !Sub "${LambdaDNS}-rule"
      Description: "Function did not run yet"
      ScheduleExpression: "rate(2 minutes)"
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaDNS.Arn
          Id: "TargetFunctionV1"

  PermissionForEventsToInvokeLambdaDNS: 
    Type: AWS::Lambda::Permission
    Condition: ServiceDNS
    Properties: 
      FunctionName: !Ref LambdaDNS
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt ScheduledRuleLambdaDNS.Arn

  LambdaVFL:
    Type: AWS::Lambda::Function
    Condition: ServiceVFL
    Properties:
      FunctionName: "cyngular-lambda-config-vpcflowlogs" 
      Description: "Created by Cyngular Security. | Configure VFL"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Ref ClientRegions
          FINAL_CRON: "cron(0 * * * ? *)"
          FIRST_RUN: "true"
          CYNGULAR_BUCKET: !Ref S3BucketArn

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 300
      Code:
        ZipFile: | 
            import boto3
            import traceback
            import os
            import logging

            def vpcflowlogs(curr_region, bucket_name):
                try:
                    logging.info('STARTING VPCFLOWLOGS...')

                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    vpc_list = ec2_client.describe_vpcs()

                    vpc_id_list = []
                    if "Vpcs" in vpc_list:                  
                        for vpc in vpc_list["Vpcs"]:
                            vpc_id_list.append(vpc["VpcId"])

                    logging.info(f'CONFIGURING VPCFLOWLOGS ON VPC-IDS: {vpc_id_list}')
                    response = ec2_client.create_flow_logs(
                        ResourceIds=vpc_id_list,
                        ResourceType='VPC',
                        TrafficType='ALL',
                        LogDestinationType = 's3',
                        LogDestination = f"arn:aws:s3:::{bucket_name}",
                        TagSpecifications=[
                            {
                                'ResourceType': 'vpc-flow-log',
                                'Tags': [
                                    {
                                        'Key': 'Name',
                                        'Value': 'Cyngular-vpc-flowlogs'
                                    },
                                ]
                            },
                        ]
                    )
                    logging.info(f'COMMAND SUCCEEDED.')

                except Exception as e:
                    if 'FlowLogAlreadyExists' in str(e):
                        pass
                    else:
                        logging.critical(str(e))

            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STRATING CYNGULARS FUNCTION...')

                LAMBDA_NAME=context.function_name
                REGIONS = os.environ['CLIENT_REGIONS']
                bucket_name = os.environ['CYNGULAR_BUCKET']
                try:
                    if os.environ.get('FIRST_RUN') == 'true':
                        logger.info('First run detected. Updating EventBridge rule schedule.')
                        try:
                            lambda_client = boto3.client('lambda')
                            events_client = boto3.client('events')
                            response = events_client.put_rule(
                                Name = f"{LAMBDA_NAME}-rule",
                                State = 'ENABLED',
                                ScheduleExpression = os.environ['FINAL_CRON'],
                                Description = 'LambdaVFL | Scheduled to run hourly',
                                EventBusName = 'default'
                            )
                            logger.info('Successfully updated the EventBridge rule: %s', response)
                            response = lambda_client.update_function_configuration(
                                FunctionName=LAMBDA_NAME,
                                Environment={'Variables': {"FIRST_RUN": "false", "CLIENT_REGIONS": REGIONS, "CYNGULAR_BUCKET": bucket_name}}
                            )
                            logger.info('Successfully updated the function configuration: %s', response)
                        except Exception as e:
                            logger.error('Error updating the EventBridge rule: %s', str(e))
                            raise

                    logger.info('STARTING VPCFLOWLOGS...')                    
                    for curr_region in REGIONS.split(','):
                        logging.info(f'AWS REGION: {curr_region}')
                        try:
                            vpcflowlogs(curr_region, bucket_name)
                        except Exception as e:
                            logging.critical(str(e))
                    logging.info('DONE!')

                except Exception as e:
                    logging.critical(str(e))
  
  ScheduledRuleLambdaVFL: 
    Type: AWS::Events::Rule
    Condition: ServiceVFL
    Properties: 
      Name: !Sub "${LambdaVFL}-rule"
      Description: "Function did not run yet"
      ScheduleExpression: "rate(2 minutes)"
      State: "ENABLED"
      Targets: 
        - Arn: !GetAtt LambdaVFL.Arn
          Id: "TargetFunctionV1"

  PermissionForEventsToInvokeLambdaVFL: 
    Type: AWS::Lambda::Permission
    Condition: ServiceVFL
    Properties:
      FunctionName: !Ref LambdaVFL
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt ScheduledRuleLambdaVFL.Arn

  LambdaDeleteVFL:
    Type: AWS::Lambda::Function
    Condition: ServiceVFL
    Properties:
      FunctionName: "cyngular-lambda-remove-vpcflowlogs"
      Description: "Created by Cyngular Security. | Remove VPCFLOWLOGS"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Ref ClientRegions

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 300
      Code:
        ZipFile: | 
            import boto3
            import traceback
            import os
            import logging

            def vpcflowlogs(curr_region):
                try:
                    logging.info('DELETING VPCFLOWLOGS...')

                    flowlogs_ids_list = []
                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    
                    response = ec2_client.describe_flow_logs(
                        Filters=[
                            {
                                'Name': 'tag:Name',
                                'Values': [
                                    'Cyngular-vpc-flowlogs'
                                ]
                            },
                        ]
                    )
                    for flow_log in response['FlowLogs']:
                        flowlogs_ids_list.append(flow_log['FlowLogId'])
                    
                    logging.info(f'DELETING THE VPCFLOWLOGS: {flowlogs_ids_list}')
                    response = ec2_client.delete_flow_logs(
                        FlowLogIds=flowlogs_ids_list
                    )
                    logging.info(f'COMMAND SUCCEEDED.')
                except Exception as e:
                    logging.critical(str(e))
                    
            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                try:
                    logger.info('STRATING CYNGULARS FUNCTION...')
                    events_client = boto3.client('events')
                    REGIONS = os.environ['CLIENT_REGIONS']

                    for curr_region in REGIONS.split(','):
                        logger.info(f'AWS REGION: {curr_region}')
                        try:
                            vpcflowlogs(curr_region)
                        except Exception as e:
                            logger.critical(str(e))
                    logger.info('DEACTIVATING EVENT BUS RULE')
                    response = events_client.disable_rule(
                        Name='cyngular-lambda-config-vpcflowlogs-rule',
                        EventBusName='default'
                    )
                    logger.info('DONE!')
                except Exception as e:
                    logger.critical(str(e))

  LambdaDeleteDNS:
    Type: AWS::Lambda::Function
    Condition: ServiceDNS
    Properties:
      FunctionName: "cyngular-lambda-remove-dns"
      Description: "Created by Cyngular Security. | Remove DNS"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Ref ClientRegions

      Runtime: "python3.9"
      Handler: index.cyngular_function
      Timeout: 300
      Code:
        ZipFile: | 
            import boto3
            import traceback
            import os
            import logging
            
            def dnslogs(curr_region):
                try:
                    r_53_client = boto3.client('route53resolver', region_name=curr_region)
                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    
                    region_query_log_configs = r_53_client.list_resolver_query_log_configs()['ResolverQueryLogConfigs']
                    cyngular_resolver_id = ''
                    
                    for region_query_log_config in region_query_log_configs:
                        try:
                            if region_query_log_config['Name'] == 'cyngular_dns':
                                cyngular_resolver_id = region_query_log_config['Id']
                                break
                        except:
                            pass

                    if cyngular_resolver_id:
                        vpc_list = ec2_client.describe_vpcs()
                        if "Vpcs" in vpc_list:                  
                            for vpc in vpc_list["Vpcs"]:
                                try:
                                    vpc_id = vpc["VpcId"]
                                    logging.info (f'DELETING CONFIGURATION OF DNSLOGS ON VPC-ID: {vpc_id}')
                                    resp = r_53_client.disassociate_resolver_query_log_config(ResolverQueryLogConfigId = cyngular_resolver_id, ResourceId = vpc_id )
                                    logging.info(f'COMMAND SUCCEEDED.')
                                except Exception as e:
                                    if "association doesn't exist" in str(e):
                                        logging.critical(f'{vpc_id} - ResolverWasNotAssociated')
                                    else:
                                        logging.critical(str(e))
                except Exception as e:
                    logging.critical(str(e))

            def cyngular_function(event, context):
                try:
                    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                    logger = logging.getLogger()
                    logger.setLevel(logging.INFO)
                    logger.info ('STRATING CYNGULARS FUNCTION...')
                    logger.info(f'DELETING DNSLOGS...')

                    events_client = boto3.client('events')
                    REGIONS = os.environ['CLIENT_REGIONS']

                    for curr_region in REGIONS.split(','):
                        logger.info(f'AWS REGION: {curr_region}')
                        try:
                            dnslogs(curr_region)
                        except Exception as e:
                            logger.critical(str(e))
                    logger.info('DEACTIVATING EVENT BUS RULE')
                    response = events_client.disable_rule(
                        Name='cyngular-lambda-config-dns-rule',
                        EventBusName='default'
                    )
                    logger.info('DONE!')

                except Exception as e:
                    logger.critical(str(e))