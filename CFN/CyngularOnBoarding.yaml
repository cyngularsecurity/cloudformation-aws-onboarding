AWSTemplateFormatVersion: 2010-09-09
Description: >-
  Cyngular
  Main OnBoarding stack template

Metadata:
  Vendor:
    Description: Cyngular Security

  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Client Info"
        Parameters:
          - ClientName
          - ClientRegions
          - OrganizationId
      - Label:
          default: "Services"
        Parameters:
          - CloudTrailBucket
          - EnableDNS
          - EnableVPCFlowLogs
          - EnableEKS
      - Label:
          default: "Cyngular Info"
        Parameters:
          - CyngularAccountId

    ParameterLabels:
      ClientName:
        default: "Company Name"
      ClientRegions:
        default: "Company Regions"
      OrganizationId:
        default: "Organization Id"
      CloudTrailBucket:
        default: "CloudTrail Bucket Name"
      EnableDNS:
        default: "DNS Enabled"
      EnableEKS:
        default: "EKS Enabled"
      EnableVPCFlowLogs:
        default: "VPCFlowLogs Enabled"
      CyngularAccountId:
        default: "Cyngular Account Id"

Mappings:
  VARS:
    "Cyngular":
      TemplateBucket: "cyngular-onboarding-templates"

Parameters:
  ClientName:
    Description: "The Client Company name (must be lowercase, can contain letters or numbers)"
    Type: String
    AllowedPattern: "^[a-z0-9]+$"
    ConstraintDescription: "Company Name should consist of only lowercase characters and numbers, and it should not start with a number."
    MinLength: 3
    MaxLength: 15

  OrganizationId:
    Description: "Specify the Company Organization id | leave empty if not deploying to an organization"
    Type: String
    Default: ""

  ClientRegions:
    Description: "The regions in which your Company operates in (comma-separated for example; us-east-1,us-east-2), make sure all regions specified are enabled in the relevent accounts"
    Type: CommaDelimitedList
    AllowedValues: [me-south-1, us-east-1, us-east-2, us-west-1, us-west-2, ap-southeast-1, ap-southeast-2, ap-south-1, ap-northeast-1, ap-northeast-2, ap-northeast-3, af-south-1, eu-west-1, eu-west-2, eu-west-3, eu-central-1, eu-central-2, eu-north-1, eu-south-1, eu-south-2, ca-central-1, sa-east-1, il-central-1, af-north-1, ap-east-1, ap-south-2, ap-southeast-3, ap-southeast-4, ap-southeast-5, ca-west-1, me-central-1]

  CyngularAccountId:
    Description: "The Cyngular Account ID to assume the read only role [851565895544]"
    Type: String
    Default: "851565895544"

  CloudTrailBucket:
    Description: "Enter a bucket Name, if you already configured CloudTrail To Send Logs to an S3 bucket. if so, also add the tag {key: 'cyngular-cloudtrail', value: 'true'} to the bucket, otherwise leave empty."
    Type: String
    Default: ""

  EnableDNS:
    Description: "Set to 'true' to enable the service if not already enabled; set to 'false' if the service is enabled or not desired. Add the tag {key: 'cyngular-dnslogs', value: 'true'} to the resource bucket only if telemetry is already collected for Cyngular analysis."
    Type: String
    AllowedValues: ["true", "false"]
    Default: "true"

  EnableEKS:
    Description: "EKS Service - Whether to Configure EKS Audit & Authenticator Logging for kubernetes Clusters."
    Type: String
    AllowedValues: ["true", "false"]
    Default: "true"

  EnableVPCFlowLogs:
    Description: "Set to 'true' to enable the service if not already enabled; set to 'false' if the service is enabled or not desired. Add the tag {key: 'cyngular-vpcflowlogs', value: 'true'} to the resource bucket only if telemetry is already collected for Cyngular analysis."
    Type: String
    AllowedValues: ["true", "false"]
    Default: "true"

Conditions:
  IsOrg: !Not [!Equals [!Ref OrganizationId, ""]]
  CreateCloudTrail: !Equals [ !Ref CloudTrailBucket, "" ]

  ServiceDNS: !Equals [ !Ref EnableDNS, "true" ]
  ServiceEKS: !Equals [ !Ref EnableEKS, "true" ]
  ServiceVFL: !Equals [ !Ref EnableVPCFlowLogs, "true" ]

Resources:
  CyngularS3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      BucketName: !Sub "cyngular-${ClientName}-bucket-${AWS::AccountId}"

      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub "cyngular-${ClientName}-bucket-${AWS::AccountId}"

        - Key: cyngular-os
          Value: true
        - Key: cyngular-visibility
          Value: true
        - !If
            - CreateCloudTrail
            - Key: cyngular-cloudtrail
              Value: true
            - !Ref AWS::NoValue
        - !If
            - ServiceDNS
            - Key: cyngular-dnslogs
              Value: true
            - !Ref AWS::NoValue
        - !If
            - ServiceVFL
            - Key: cyngular-vpcflowlogs
              Value: true
            - !Ref AWS::NoValue
        - !If
            - ServiceEKS
            - Key: cyngular-ekslogs
              Value: true
            - !Ref AWS::NoValue

  S3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref CyngularS3Bucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: 'LambdaRead'
            Effect: Allow
            Principal: 
              AWS: [
                !Sub "arn:aws:iam::${AWS::AccountId}:root",
                !Sub "arn:aws:iam::${CyngularAccountId}:root"                
              ]
            Action:
              - 's3:*'
            Resource:
              - !GetAtt CyngularS3Bucket.Arn
              - !Sub "arn:aws:s3:::${CyngularS3Bucket}/*"

          - !If
            - CreateCloudTrail
            - Sid: 'CloudTrailAclCheck'
              Effect: Allow
              Principal:
                Service: "cloudtrail.amazonaws.com"
              Action: 's3:GetBucketAcl'
              Resource: !GetAtt CyngularS3Bucket.Arn
              Condition:
                StringEquals:
                  AWS:SourceArn: !Sub "arn:aws:cloudtrail:${AWS::Region}:${AWS::AccountId}:trail/cyngular-cloudtrail"
            - !Ref "AWS::NoValue"

          - !If 
            - CreateCloudTrail
            - Sid: 'CloudTrailWrite'
              Effect: Allow
              Principal: 
                Service: "cloudtrail.amazonaws.com"
              Action:
                - 's3:PutObject'
              Resource: 
                - !Sub "arn:aws:s3:::${CyngularS3Bucket}/AWSLogs/${AWS::AccountId}/*"
                - !If 
                  - IsOrg
                  - !Sub "arn:aws:s3:::${CyngularS3Bucket}/AWSLogs/${OrganizationId}/*"
                  - !Ref "AWS::NoValue"
              Condition:
                StringEquals:
                  s3:x-amz-acl: "bucket-owner-full-control"
                  AWS:SourceArn: !Sub "arn:aws:cloudtrail:${AWS::Region}:${AWS::AccountId}:trail/cyngular-cloudtrail"
            - !Ref "AWS::NoValue"

  ClientCloudTrail:
    DependsOn: S3BucketPolicy
    Condition: CreateCloudTrail
    Type: AWS::CloudTrail::Trail
    Properties:
      TrailName: cyngular-cloudtrail
      S3BucketName: !Ref CyngularS3Bucket
      InsightSelectors:
        - InsightType: ApiCallRateInsight
        - InsightType: ApiErrorRateInsight
      EventSelectors:
        - IncludeManagementEvents: true
          ExcludeManagementEventSources:
            - kms.amazonaws.com
          DataResources:
            - Type: AWS::Lambda::Function
              Values:
                - arn:aws:lambda
      IsLogging: true
      IsMultiRegionTrail: true
      IsOrganizationTrail: !If [IsOrg, true, false]
      IncludeGlobalServiceEvents: true
      Tags:
        - Key: Name
          Value: cyngular-cloudtrail

  ClientCyngularRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "cyngular-readonly-role-${ClientName}"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${CyngularAccountId}:root"
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: cyngular-readonly-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: 'ReadOnly'
                Effect: Allow
                Resource: '*'
                Action:
                  - iam:List*
                  - iam:Get*
                  - iam:GenerateServiceLastAccessedDetails

                  - organizations:Describe*
                  - organizations:List*

                  - ce:List*
                  - ce:Get*
                  - ce:Describe*

                  - s3:List*
                  - s3:Describe*
                  - s3:GetBucketAcl
                  - s3:GetBucketLocation
                  - s3:GetBucketPolicy
                  - s3:GetBucketPolicyStatus
                  - s3:GetEncryptionConfiguration
                  - s3:GetBucketOwnershipControls
                  - s3:GetBucketTagging
                  - s3:GetIntelligentTieringConfiguration
                  - s3:GetAccountPublicAccessBlock
                  - s3:GetBucketPublicAccessBlock

                  - logs:List*
                  - logs:Describe*
                  - logs:Get*
                  - logs:FilterLogEvents
                  - logs:StartQuery
                  - cloudwatch:GetMetricStatistics

                  - ec2:List*
                  - ec2:CreateTags
                  - ec2:Describe*
                  - ec2:GetImageBlockPublicAccessState
                  - ecr:Describe*
                  - ecr:List*
                  - eks:Describe*
                  - eks:List*
                  - ecs:List*
                  - ecs:Describe*
                  - lambda:List*
                  - lambda:Get*
                  - rds:List*
                  - rds:Describe*

                  - cloudformation:Describe*
                  - cloudformation:List*
                  - cloudformation:Get*
                  
                  - tag:GetResources

                  - 'route53:Get*'
                  - 'route53:List*'
                  - 'route53:TestDNSAnswer'

                  - 'cloudtrail:GetTrail'
                  - 'cloudtrail:DescribeTrails'
                  - 'cloudtrail:GetTrailStatus'
                  - 'cloudtrail:LookupEvents'
                  - 'cloudtrail:ListTags'
                  - 'cloudtrail:ListTrails'
                  - 'cloudtrail:GetEventSelectors'
                  - 'cloudtrail:GetInsightSelectors'

                  - 'kms:Describe*'
                  - 'kms:Get*'
                  - 'kms:List*'

                  - "events:ListRules"
                  - "events:ListTargetsByRule"
                  - "events:ListEventBuses"
                  - "events:DescribeEventBus"
                  - "events:DescribeRule"
                  - "events:TestEventPattern"
                  - "events:PutRule"
                  - "events:PutTargets"

                  - "cloudwatch:ListMetrics"
                  - "cloudwatch:GetMetricData"


              - Sid: 'Ec2CyngularSnapshot'
                Effect: Allow
                Action:
                  - ec2:DeleteSnapshot
                  - ec2:ModifySnapshotAttribute
                Resource: '*'
                Condition:
                  StringLike:
                    aws:ResourceTag/Name: cyngular*
              - Sid: 'Ec2CreateSnapshot'
                Effect: Allow
                Resource: '*'
                Action:
                  - ec2:CopySnapshot
                  - ec2:CreateSnapshot
                  - ec2:CreateSnapshots
              - Sid: 'CyngularBucketAdmin'
                Effect: Allow
                Resource:
                  - !GetAtt CyngularS3Bucket.Arn
                  - !Sub ["${bucket_arn}/*", bucket_arn: !GetAtt CyngularS3Bucket.Arn]
                Action:
                  - "s3:*"
              - Sid: 'KmsPartial'
                Effect: Allow
                Resource: '*'
                Action:
                  - kms:Decrypt
                  - kms:CreateGrant
              - Sid: 'CyngularKmsKey'
                Effect: Allow
                Resource: '*'
                Action:
                  - kms:*
                Condition:
                  StringLike:
                    aws:ResourceTag/Name: cyngular*
              - Sid: 'ListRegionsOnAccounts'
                Effect: "Allow"
                Action:
                  - "account:ListRegions"
                Resource:
                  - arn:aws:account::*:account/o-*/*
                  - arn:aws:account::*:account
      Tags:
        - Key: Vendor
          Value: "Cyngular Security"

  LambdasRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "cyngular-lambdas-role-${ClientName}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service: 
                - "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: !Sub "cyngular-lambdas-policy-${ClientName}"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: 'CyngularGeneral'
                Effect: Allow
                Resource: '*'
                Action:
                  - ssm:*
                  - logs:*
                  - route53resolver:*
  
                  - organizations:ListAccounts
                  # - organizations:ListOrganizationalUnitsForParent

                  - ec2:Describe*
                  - ec2:CreateFlowLogs
                  - ec2:DeleteFlowLogs
                  - ec2:CreateTags
                  - ec2:DeleteTags
                  - eks:List*
                  - eks:UpdateClusterConfig

                  - events:PutRule
                  - lambda:UpdateFunctionConfiguration

                  # - sts:GetCallerIdentity
                  # - lambda:InvokeFunction
                  - events:DisableRule

              - Sid: 'CyngularBucketAdmin'
                Effect: Allow
                Resource:
                  - !GetAtt CyngularS3Bucket.Arn
                  - !Sub ["${bucket_arn}/*", bucket_arn: !GetAtt CyngularS3Bucket.Arn]
                Action:
                  - "s3:*"

              - Sid: 'EditEKS'
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:eks:*:${AWS::AccountId}:cluster/*"
                  - !Sub "arn:aws:eks:*:${AWS::AccountId}:access-entry/*/role/${AWS::AccountId}/cyngular-readonly-role-${ClientName}/*"
                Action:
                  - "eks:CreateAccessEntry"
                  - "eks:AssociateAccessPolicy"
                  - "eks:DescribeCluster"
      Tags:
        - Key: Vendor
          Value: "Cyngular Security"

  ManagerLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "cyngular-manager-lambda-role-${ClientName}"
      MaxSessionDuration: 43200

      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "lambda.amazonaws.com"
            Action: sts:AssumeRole
      Policies:
        - PolicyName: "ManagerLambdaRolePolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: 'InvokeBucketPolicyLambda'
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
                  - lambda:GetFunction
                Resource:
                  - !GetAtt LambdaUpdateCyngularBucketPolicy.Arn
              - Sid: 'StackSetManager'
                Effect: Allow
                Resource: "*"
                Action:
                  - cloudformation:GetTemplateSummary
                  - cloudformation:ListStackSetOperationResults
                  - cloudformation:DescribeStacks
                  - cloudformation:DescribeStackSet
                  - cloudformation:DescribeStackSetOperation
                  - cloudformation:CreateStack
                  - cloudformation:CreateStackSet
                  - cloudformation:CreateStackInstances
                  - cloudformation:DeleteStackSet
                  - cloudformation:DeleteStackInstances
                  - cloudformation:TagResource
              - Sid: 'OrgManager'
                Effect: Allow
                Resource: "*"
                Action:
                  - organizations:ListAccounts
                  - organizations:ListRoots
              - Sid: 'LogsManager'
                Effect: Allow
                Action: logs:*
                Resource: "arn:aws:logs:*:*:*"
              - Sid: 'IdentityManager'
                Effect: Allow
                Resource: "*"
                Action:
                  - iam:GetRole
                  - iam:getRolePolicy
                  - iam:PutRolePolicy
                  - iam:DetachRolePolicy
                  - iam:AttachRolePolicy
                  - iam:DeleteRolePolicy
              - Sid: 'GetStackSetTemplates'
                Effect: "Allow"
                Resource:
                  - !Sub
                    - "arn:aws:s3:::${bucket_name}/stacks/*"
                    - bucket_name: !FindInMap [VARS, Cyngular, TemplateBucket]
                Action:
                  - "s3:GetObject"

  LambdaAdminAndExecRole:
    Type: AWS::IAM::Role
    DependsOn: [CyngularS3Bucket]
    Properties:
      RoleName: !Sub "cyngular-admin-and-exec-roles-lambda-role-${ClientName}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: "AdminExecLambdaRolePolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Resource: "*"
                Action:
                  - "cloudformation:DescribeStacks"
                  - "cloudformation:DescribeStackSet"
                  - "cloudformation:DescribeStackSetOperation"
                  - "cloudformation:DescribeStackEvents"
                  - "cloudformation:CreateStack"
                  - "cloudformation:CreateStackSet"
                  - "cloudformation:CreateStackInstances"

                  - "cloudformation:DeleteStackInstances"
                  - "cloudformation:DeleteStackSet"
                  - "cloudformation:ListStackSetOperationResults"
                  - "cloudformation:ListStackInstances"
                  - "cloudformation:UpdateStackSet"
                  - "cloudformation:UpdateStackInstances"
                  - "cloudformation:ExecuteChangeSet"

                  - "organizations:ListAccounts"
                  - "organizations:ListRoots"
                  
                  - "iam:GetRole"
                  - "iam:getRolePolicy"
                  - "iam:CreateRole"
                  - "iam:AttachRolePolicy"
                  - "iam:PutRolePolicy"

                  - "logs:*"
              - Sid: 'GetStackSetTemplates'
                Effect: "Allow"
                Resource:
                  - !Sub
                    - "arn:aws:s3:::${bucket_name}/stacks/*"
                    - bucket_name: !FindInMap [VARS, Cyngular, TemplateBucket]
                Action:
                  - "s3:GetObject"

  LambdaOS:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "cyngular-lambda-config-os"
      Description: "Created by Cyngular Security | Configure OS Service"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Join [" ", !Ref ClientRegions]
          FINAL_CRON: "cron(0 0 * * ? *)"
          FIRST_RUN: "true"

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 900
      Code:
        ZipFile: |
            import boto3
            import traceback
            import os
            import logging

            def osinternals(curr_region):
                try:
                    logging.info('STARTING OS INTERNALS...')
                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    ssm_client = boto3.client('ssm', region_name=curr_region)

                    all_instances = ec2_client.describe_instances()
                    instance_ids = []
                    for reservation in all_instances['Reservations']:
                        for instance in reservation['Instances']:
                            instance_ids.append(instance['InstanceId'])

                    auditd_rules = 'IyAgICAgIF9fXyAgICAgICAgICAgICBfX18gX18gICAgICBfXwojICAgICAvICAgfCBfXyAgX19fX19fLyAoXykgL19fX19fLyAvCiMgICAgLyAvfCB8LyAvIC8gLyBfXyAgLyAvIF9fLyBfXyAgLwojICAgLyBfX18gLyAvXy8gLyAvXy8gLyAvIC9fLyAvXy8gLwojICAvXy8gIHxfXF9fLF8vXF9fLF8vXy9cX18vXF9fLF8vCiMKIyBMaW51eCBBdWRpdCBEYWVtb24gLSBCZXN0IFByYWN0aWNlIENvbmZpZ3VyYXRpb24KIyAvZXRjL2F1ZGl0L2F1ZGl0LnJ1bGVzCiMKIyBDb21waWxlZCBieSBDeW5ndWxhciBTZWN1cml0eQojCgojIFJlbW92ZSBhbnkgZXhpc3RpbmcgcnVsZXMKLUQKCiMgQnVmZmVyIFNpemUKIyMgRmVlbCBmcmVlIHRvIGluY3JlYXNlIHRoaXMgaWYgdGhlIG1hY2hpbmUgcGFuaWMncwotYiA4MTkyCgojIEZhaWx1cmUgTW9kZQojIyBQb3NzaWJsZSB2YWx1ZXM6IDAgKHNpbGVudCksIDEgKHByaW50aywgcHJpbnQgYSBmYWlsdXJlIG1lc3NhZ2UpLCAyIChwYW5pYywgaGFsdCB0aGUgc3lzdGVtKQotZiAxCgojIElnbm9yZSBlcnJvcnMKIyMgZS5nLiBjYXVzZWQgYnkgdXNlcnMgb3IgZmlsZXMgbm90IGZvdW5kIGluIHRoZSBsb2NhbCBlbnZpcm9ubWVudAotaQoKIyBTZWxmIEF1ZGl0aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMgQXVkaXQgdGhlIGF1ZGl0IGxvZ3MKIyMjIFN1Y2Nlc3NmdWwgYW5kIHVuc3VjY2Vzc2Z1bCBhdHRlbXB0cyB0byByZWFkIGluZm9ybWF0aW9uIGZyb20gdGhlIGF1ZGl0IHJlY29yZHMKLXcgL3Zhci9sb2cvYXVkaXQvIC1rIGF1ZGl0bG9nCgojIyBBdWRpdGQgY29uZmlndXJhdGlvbgojIyMgTW9kaWZpY2F0aW9ucyB0byBhdWRpdCBjb25maWd1cmF0aW9uIHRoYXQgb2NjdXIgd2hpbGUgdGhlIGF1ZGl0IGNvbGxlY3Rpb24gZnVuY3Rpb25zIGFyZSBvcGVyYXRpbmcKLXcgL2V0Yy9hdWRpdC8gLXAgd2EgLWsgYXVkaXRjb25maWcKLXcgL2V0Yy9saWJhdWRpdC5jb25mIC1wIHdhIC1rIGF1ZGl0Y29uZmlnCi13IC9ldGMvYXVkaXNwLyAtcCB3YSAtayBhdWRpc3Bjb25maWcKCiMjIE1vbml0b3IgZm9yIHVzZSBvZiBhdWRpdCBtYW5hZ2VtZW50IHRvb2xzCi13IC9zYmluL2F1ZGl0Y3RsIC1wIHggLWsgYXVkaXR0b29scwotdyAvc2Jpbi9hdWRpdGQgLXAgeCAtayBhdWRpdHRvb2xzCi13IC91c3Ivc2Jpbi9hdWdlbnJ1bGVzIC1wIHggLWsgYXVkaXR0b29scwoKIyBGaWx0ZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMjIFdlIHB1dCB0aGVzZSBlYXJseSBiZWNhdXNlIGF1ZGl0IGlzIGEgZmlyc3QgbWF0Y2ggd2lucyBzeXN0ZW0uCgojIyBleGNsdWRlcwotYSBuZXZlcixleGl0IC1GIGV4ZT0vdXNyL3NiaW4vY3JvbiAtayBleGNsdWRlX2Nyb24KLWEgbmV2ZXIsZXhpdCAtRiBleGU9L3Vzci9iaW4vZHBrZyAtayBleGNsdWRlX2Rwa2cKCiMjIElnbm9yZSBTRUxpbnV4IEFWQyByZWNvcmRzCi1hIGFsd2F5cyxleGNsdWRlIC1GIG1zZ3R5cGU9QVZDCgojIyBJZ25vcmUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSByZWNvcmRzCi1hIGFsd2F5cyxleGNsdWRlIC1GIG1zZ3R5cGU9Q1dECgojIyBDcm9uIGpvYnMgZmlsbCB0aGUgbG9ncyB3aXRoIHN0dWZmIHdlIG5vcm1hbGx5IGRvbid0IHdhbnQgKHdvcmtzIHdpdGggU0VMaW51eCkKLWEgbmV2ZXIsdXNlciAtRiBzdWJqX3R5cGU9Y3JvbmRfdAotYSBuZXZlcixleGl0IC1GIHN1YmpfdHlwZT1jcm9uZF90CgojIyBUaGlzIHByZXZlbnRzIGNocm9ueSBmcm9tIG92ZXJ3aGVsbWluZyB0aGUgbG9ncwotYSBuZXZlcixleGl0IC1GIGFyY2g9YjY0IC1TIGFkanRpbWV4IC1GIGF1aWQ9dW5zZXQgLUYgdWlkPWNocm9ueSAtRiBzdWJqX3R5cGU9Y2hyb255ZF90CgojIyBUaGlzIGlzIG5vdCB2ZXJ5IGludGVyZXN0aW5nIGFuZCB3YXN0ZXMgYSBsb3Qgb2Ygc3BhY2UgaWYgdGhlIHNlcnZlciBpcyBwdWJsaWMgZmFjaW5nCi1hIGFsd2F5cyxleGNsdWRlIC1GIG1zZ3R5cGU9Q1JZUFRPX0tFWV9VU0VSCgojIyBWTVdhcmUgdG9vbHMKLWEgbmV2ZXIsZXhpdCAtRiBhcmNoPWIzMiAtUyBmb3JrIC1GIHN1Y2Nlc3M9MCAtRiBwYXRoPS91c3IvbGliL3Ztd2FyZS10b29scyAtRiBzdWJqX3R5cGU9aW5pdHJjX3QgLUYgZXhpdD0tMgotYSBuZXZlcixleGl0IC1GIGFyY2g9YjY0IC1TIGZvcmsgLUYgc3VjY2Vzcz0wIC1GIHBhdGg9L3Vzci9saWIvdm13YXJlLXRvb2xzIC1GIHN1YmpfdHlwZT1pbml0cmNfdCAtRiBleGl0PS0yCgojIyBIaWdoIFZvbHVtZSBFdmVudCBGaWx0ZXIgKGVzcGVjaWFsbHkgb24gTGludXggV29ya3N0YXRpb25zKQotYSBuZXZlcixleGl0IC1GIGFyY2g9YjMyIC1GIGRpcj0vZGV2L3NobSAtayBzaGFyZWRtZW1hY2Nlc3MKLWEgbmV2ZXIsZXhpdCAtRiBhcmNoPWI2NCAtRiBkaXI9L2Rldi9zaG0gLWsgc2hhcmVkbWVtYWNjZXNzCi1hIG5ldmVyLGV4aXQgLUYgYXJjaD1iMzIgLUYgZGlyPS92YXIvbG9jay9sdm0gLWsgbG9ja2x2bQotYSBuZXZlcixleGl0IC1GIGFyY2g9YjY0IC1GIGRpcj0vdmFyL2xvY2svbHZtIC1rIGxvY2tsdm0KCiMjIEZpbGVCZWF0IAotYSBuZXZlcixleGl0IC1GIGFyY2g9YjMyIC1GIHBhdGg9L29wdC9maWxlYmVhdCAtayBmaWxlYmVhdAotYSBuZXZlcixleGl0IC1GIGFyY2g9YjY0IC1GIHBhdGg9L29wdC9maWxlYmVhdCAtayBmaWxlYmVhdAoKIyMgTW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZmlsdGVyIGV2ZW50cwojIyMgaHR0cHM6Ly9hY2Nlc3MucmVkaGF0LmNvbS9zb2x1dGlvbnMvMjQ4MjIyMQoKIyBSdWxlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMgS2VybmVsIHBhcmFtZXRlcnMKLXcgL2V0Yy9zeXNjdGwuY29uZiAtcCB3YSAtayBzeXNjdGwKLXcgL2V0Yy9zeXNjdGwuZCAtcCB3YSAtayBzeXNjdGwKCiMjIEtlcm5lbCBtb2R1bGUgbG9hZGluZyBhbmQgdW5sb2FkaW5nCi1hIGFsd2F5cyxleGl0IC1GIHBlcm09eCAtRiBhdWlkIT0tMSAtRiBwYXRoPS9zYmluL2luc21vZCAtayBtb2R1bGVzCi1hIGFsd2F5cyxleGl0IC1GIHBlcm09eCAtRiBhdWlkIT0tMSAtRiBwYXRoPS9zYmluL21vZHByb2JlIC1rIG1vZHVsZXMKLWEgYWx3YXlzLGV4aXQgLUYgcGVybT14IC1GIGF1aWQhPS0xIC1GIHBhdGg9L3NiaW4vcm1tb2QgLWsgbW9kdWxlcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBmaW5pdF9tb2R1bGUgLVMgaW5pdF9tb2R1bGUgLVMgZGVsZXRlX21vZHVsZSAtRiBhdWlkIT0tMSAtayBtb2R1bGVzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGZpbml0X21vZHVsZSAtUyBpbml0X21vZHVsZSAtUyBkZWxldGVfbW9kdWxlIC1GIGF1aWQhPS0xIC1rIG1vZHVsZXMKCiMjIE1vZHByb2JlIGNvbmZpZ3VyYXRpb24KLXcgL2V0Yy9tb2Rwcm9iZS5jb25mIC1wIHdhIC1rIG1vZHByb2JlCi13IC9ldGMvbW9kcHJvYmUuZCAtcCB3YSAtayBtb2Rwcm9iZQoKIyMgS0V4ZWMgdXNhZ2UgKGFsbCBhY3Rpb25zKQotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBrZXhlY19sb2FkIC1rIEtFWEVDCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHN5c19rZXhlY19sb2FkIC1rIEtFWEVDCgojIyBTcGVjaWFsIGZpbGVzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIG1rbm9kIC1TIG1rbm9kYXQgLWsgc3BlY2lhbGZpbGVzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIG1rbm9kIC1TIG1rbm9kYXQgLWsgc3BlY2lhbGZpbGVzCgojIyBNb3VudCBvcGVyYXRpb25zIChvbmx5IGF0dHJpYnV0YWJsZSkKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgbW91bnQgLVMgdW1vdW50MiAtRiBhdWlkIT0tMSAtayBtb3VudAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBtb3VudCAtUyB1bW91bnQgLVMgdW1vdW50MiAtRiBhdWlkIT0tMSAtayBtb3VudAoKIyMgQ2hhbmdlIHN3YXAgKG9ubHkgYXR0cmlidXRhYmxlKQotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBzd2Fwb24gLVMgc3dhcG9mZiAtRiBhdWlkIT0tMSAtayBzd2FwCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHN3YXBvbiAtUyBzd2Fwb2ZmIC1GIGF1aWQhPS0xIC1rIHN3YXAKCiMjIFRpbWUKIy1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1GIHVpZCE9bnRwIC1TIGFkanRpbWV4IC1TIHNldHRpbWVvZmRheSAtUyBjbG9ja19zZXR0aW1lIC1rIHRpbWUKIy1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1GIHVpZCE9bnRwIC1TIGFkanRpbWV4IC1TIHNldHRpbWVvZmRheSAtUyBjbG9ja19zZXR0aW1lIC1rIHRpbWUKIyMjIExvY2FsIHRpbWUgem9uZQojLXcgL2V0Yy9sb2NhbHRpbWUgLXAgd2EgLWsgbG9jYWx0aW1lCgojIyBTdHVubmVsCi13IC91c3Ivc2Jpbi9zdHVubmVsIC1wIHggLWsgc3R1bm5lbAotdyAvdXNyL2Jpbi9zdHVubmVsIC1wIHggLWsgc3R1bm5lbAoKIyMgQ3JvbiBjb25maWd1cmF0aW9uICYgc2NoZWR1bGVkIGpvYnMKLXcgL2V0Yy9jcm9uLmFsbG93IC1wIHdhIC1rIGNyb24KLXcgL2V0Yy9jcm9uLmRlbnkgLXAgd2EgLWsgY3JvbgotdyAvZXRjL2Nyb24uZC8gLXAgd2EgLWsgY3JvbgotdyAvZXRjL2Nyb24uZGFpbHkvIC1wIHdhIC1rIGNyb24KLXcgL2V0Yy9jcm9uLmhvdXJseS8gLXAgd2EgLWsgY3JvbgotdyAvZXRjL2Nyb24ubW9udGhseS8gLXAgd2EgLWsgY3JvbgotdyAvZXRjL2Nyb24ud2Vla2x5LyAtcCB3YSAtayBjcm9uCi13IC9ldGMvY3JvbnRhYiAtcCB3YSAtayBjcm9uCi13IC92YXIvc3Bvb2wvY3Jvbi8gLWsgY3JvbgoKIyMgVXNlciwgZ3JvdXAsIHBhc3N3b3JkIGRhdGFiYXNlcwotdyAvZXRjL2dyb3VwIC1wIHdhIC1rIGV0Y2dyb3VwCi13IC9ldGMvcGFzc3dkIC1wIHdhIC1rIGV0Y3Bhc3N3ZAotdyAvZXRjL2dzaGFkb3cgLWsgZXRjZ3JvdXAKLXcgL2V0Yy9zaGFkb3cgLWsgZXRjcGFzc3dkCi13IC9ldGMvc2VjdXJpdHkvb3Bhc3N3ZCAtayBvcGFzc3dkCgojIyBTdWRvZXJzIGZpbGUgY2hhbmdlcwotdyAvZXRjL3N1ZG9lcnMgLXAgd2EgLWsgYWN0aW9ucwotdyAvZXRjL3N1ZG9lcnMuZC8gLXAgd2EgLWsgYWN0aW9ucwoKIyMgUGFzc3dkCi13IC91c3IvYmluL3Bhc3N3ZCAtcCB4IC1rIHBhc3N3ZF9tb2RpZmljYXRpb24KCiMjIFRvb2xzIHRvIGNoYW5nZSBncm91cCBpZGVudGlmaWVycwotdyAvdXNyL3NiaW4vZ3JvdXBhZGQgLXAgeCAtayBncm91cF9tb2RpZmljYXRpb24KLXcgL3Vzci9zYmluL2dyb3VwbW9kIC1wIHggLWsgZ3JvdXBfbW9kaWZpY2F0aW9uCi13IC91c3Ivc2Jpbi9hZGRncm91cCAtcCB4IC1rIGdyb3VwX21vZGlmaWNhdGlvbgotdyAvdXNyL3NiaW4vdXNlcmFkZCAtcCB4IC1rIHVzZXJfbW9kaWZpY2F0aW9uCi13IC91c3Ivc2Jpbi91c2VyZGVsIC1wIHggLWsgdXNlcl9tb2RpZmljYXRpb24KLXcgL3Vzci9zYmluL3VzZXJtb2QgLXAgeCAtayB1c2VyX21vZGlmaWNhdGlvbgotdyAvdXNyL3NiaW4vYWRkdXNlciAtcCB4IC1rIHVzZXJfbW9kaWZpY2F0aW9uCgojIyBMb2dpbiBjb25maWd1cmF0aW9uIGFuZCBpbmZvcm1hdGlvbgotdyAvZXRjL2xvZ2luLmRlZnMgLXAgd2EgLWsgbG9naW4KLXcgL2V0Yy9zZWN1cmV0dHkgLXAgd2EgLWsgbG9naW4KLXcgL3Zhci9sb2cvZmFpbGxvZyAtcCB3YSAtayBsb2dpbgotdyAvdmFyL2xvZy9sYXN0bG9nIC1wIHdhIC1rIGxvZ2luCi13IC92YXIvbG9nL3RhbGx5bG9nIC1wIHdhIC1rIGxvZ2luCgojIyBOZXR3b3JrIEVudmlyb25tZW50CiMjIyBDaGFuZ2VzIHRvIGhvc3RuYW1lCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHNldGhvc3RuYW1lIC1TIHNldGRvbWFpbm5hbWUgLWsgbmV0d29ya19tb2RpZmljYXRpb25zCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHNldGhvc3RuYW1lIC1TIHNldGRvbWFpbm5hbWUgLWsgbmV0d29ya19tb2RpZmljYXRpb25zCgojIyMgU3VjY2Vzc2Z1bCBJUHY0IENvbm5lY3Rpb25zCiMtYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBjb25uZWN0IC1GIGEyPTE2IC1GIHN1Y2Nlc3M9MSAtRiBrZXk9bmV0d29ya19jb25uZWN0XzQKIy1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGNvbm5lY3QgLUYgYTI9MTYgLUYgc3VjY2Vzcz0xIC1GIGtleT1uZXR3b3JrX2Nvbm5lY3RfNAoKIyMjIFN1Y2Nlc3NmdWwgSVB2NiBDb25uZWN0aW9ucwojLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgY29ubmVjdCAtRiBhMj0yOCAtRiBzdWNjZXNzPTEgLUYga2V5PW5ldHdvcmtfY29ubmVjdF82CiMtYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBjb25uZWN0IC1GIGEyPTI4IC1GIHN1Y2Nlc3M9MSAtRiBrZXk9bmV0d29ya19jb25uZWN0XzYKCiMjIyBDaGFuZ2VzIHRvIG90aGVyIGZpbGVzCi13IC9ldGMvaG9zdHMgLXAgd2EgLWsgbmV0d29ya19tb2RpZmljYXRpb25zCi13IC9ldGMvc3lzY29uZmlnL25ldHdvcmsgLXAgd2EgLWsgbmV0d29ya19tb2RpZmljYXRpb25zCi13IC9ldGMvc3lzY29uZmlnL25ldHdvcmstc2NyaXB0cyAtcCB3IC1rIG5ldHdvcmtfbW9kaWZpY2F0aW9ucwotdyAvZXRjL25ldHdvcmsvIC1wIHdhIC1rIG5ldHdvcmsKLWEgYWx3YXlzLGV4aXQgLUYgZGlyPS9ldGMvTmV0d29ya01hbmFnZXIvIC1GIHBlcm09d2EgLWsgbmV0d29ya19tb2RpZmljYXRpb25zCgojIyMgQ2hhbmdlcyB0byBpc3N1ZQotdyAvZXRjL2lzc3VlIC1wIHdhIC1rIGV0Y2lzc3VlCi13IC9ldGMvaXNzdWUubmV0IC1wIHdhIC1rIGV0Y2lzc3VlCgojIyBTeXN0ZW0gc3RhcnR1cCBzY3JpcHRzCi13IC9ldGMvaW5pdHRhYiAtcCB3YSAtayBpbml0Ci13IC9ldGMvaW5pdC5kLyAtcCB3YSAtayBpbml0Ci13IC9ldGMvaW5pdC8gLXAgd2EgLWsgaW5pdAoKIyMgTGlicmFyeSBzZWFyY2ggcGF0aHMKLXcgL2V0Yy9sZC5zby5jb25mIC1wIHdhIC1rIGxpYnBhdGgKLXcgL2V0Yy9sZC5zby5jb25mLmQgLXAgd2EgLWsgbGlicGF0aAoKIyMgU3lzdGVtd2lkZSBsaWJyYXJ5IHByZWxvYWRzIChMRF9QUkVMT0FEKQotdyAvZXRjL2xkLnNvLnByZWxvYWQgLXAgd2EgLWsgc3lzdGVtd2lkZV9wcmVsb2FkcwoKIyMgUGFtIGNvbmZpZ3VyYXRpb24KLXcgL2V0Yy9wYW0uZC8gLXAgd2EgLWsgcGFtCi13IC9ldGMvc2VjdXJpdHkvbGltaXRzLmNvbmYgLXAgd2EgIC1rIHBhbQotdyAvZXRjL3NlY3VyaXR5L2xpbWl0cy5kIC1wIHdhICAtayBwYW0KLXcgL2V0Yy9zZWN1cml0eS9wYW1fZW52LmNvbmYgLXAgd2EgLWsgcGFtCi13IC9ldGMvc2VjdXJpdHkvbmFtZXNwYWNlLmNvbmYgLXAgd2EgLWsgcGFtCi13IC9ldGMvc2VjdXJpdHkvbmFtZXNwYWNlLmQgLXAgd2EgLWsgcGFtCi13IC9ldGMvc2VjdXJpdHkvbmFtZXNwYWNlLmluaXQgLXAgd2EgLWsgcGFtCgojIyBNYWlsIGNvbmZpZ3VyYXRpb24KIy13IC9ldGMvYWxpYXNlcyAtcCB3YSAtayBtYWlsCiMtdyAvZXRjL3Bvc3RmaXgvIC1wIHdhIC1rIG1haWwKIy13IC9ldGMvZXhpbTQvIC1wIHdhIC1rIG1haWwKCiMjIFNTSCBjb25maWd1cmF0aW9uCi13IC9ldGMvc3NoL3NzaGRfY29uZmlnIC1rIHNzaGQKLXcgL2V0Yy9zc2gvc3NoZF9jb25maWcuZCAtayBzc2hkCgojIyByb290IHNzaCBrZXkgdGFtcGVyaW5nCi13IC9yb290Ly5zc2ggLXAgd2EgLWsgcm9vdGtleQoKIyBTeXN0ZW1kCi13IC9iaW4vc3lzdGVtY3RsIC1wIHggLWsgc3lzdGVtZAotdyAvZXRjL3N5c3RlbWQvIC1wIHdhIC1rIHN5c3RlbWQKCiMjIFNFTGludXggZXZlbnRzIHRoYXQgbW9kaWZ5IHRoZSBzeXN0ZW0ncyBNYW5kYXRvcnkgQWNjZXNzIENvbnRyb2xzIChNQUMpCi13IC9ldGMvc2VsaW51eC8gLXAgd2EgLWsgbWFjX3BvbGljeQoKIyMgQ3JpdGljYWwgZWxlbWVudHMgYWNjZXNzIGZhaWx1cmVzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIG9wZW4gLUYgZGlyPS9ldGMgLUYgc3VjY2Vzcz0wIC1rIHVuYXV0aGVkZmlsZWFjY2VzcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBvcGVuIC1GIGRpcj0vYmluIC1GIHN1Y2Nlc3M9MCAtayB1bmF1dGhlZGZpbGVhY2Nlc3MKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgb3BlbiAtRiBkaXI9L3NiaW4gLUYgc3VjY2Vzcz0wIC1rIHVuYXV0aGVkZmlsZWFjY2VzcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBvcGVuIC1GIGRpcj0vdXNyL2JpbiAtRiBzdWNjZXNzPTAgLWsgdW5hdXRoZWRmaWxlYWNjZXNzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIG9wZW4gLUYgZGlyPS91c3Ivc2JpbiAtRiBzdWNjZXNzPTAgLWsgdW5hdXRoZWRmaWxlYWNjZXNzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIG9wZW4gLUYgZGlyPS92YXIgLUYgc3VjY2Vzcz0wIC1rIHVuYXV0aGVkZmlsZWFjY2VzcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBvcGVuIC1GIGRpcj0vaG9tZSAtRiBzdWNjZXNzPTAgLWsgdW5hdXRoZWRmaWxlYWNjZXNzCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIG9wZW4gLUYgZGlyPS9zcnYgLUYgc3VjY2Vzcz0wIC1rIHVuYXV0aGVkZmlsZWFjY2VzcwoKIyMgUHJvY2VzcyBJRCBjaGFuZ2UgKHN3aXRjaGluZyBhY2NvdW50cykgYXBwbGljYXRpb25zCi13IC9iaW4vc3UgLXAgeCAtayBwcml2X2VzYwotdyAvdXNyL2Jpbi9zdWRvIC1wIHggLWsgcHJpdl9lc2MKLXcgL2V0Yy9zdWRvZXJzIC1wIHJ3IC1rIHByaXZfZXNjCi13IC9ldGMvc3Vkb2Vycy5kIC1wIHJ3IC1rIHByaXZfZXNjCgojIyBQb3dlciBzdGF0ZQotdyAvc2Jpbi9zaHV0ZG93biAtcCB4IC1rIHBvd2VyCi13IC9zYmluL3Bvd2Vyb2ZmIC1wIHggLWsgcG93ZXIKLXcgL3NiaW4vcmVib290IC1wIHggLWsgcG93ZXIKLXcgL3NiaW4vaGFsdCAtcCB4IC1rIHBvd2VyCgojIyBTZXNzaW9uIGluaXRpYXRpb24gaW5mb3JtYXRpb24KLXcgL3Zhci9ydW4vdXRtcCAtcCB3YSAtayBzZXNzaW9uCi13IC92YXIvbG9nL2J0bXAgLXAgd2EgLWsgc2Vzc2lvbgotdyAvdmFyL2xvZy93dG1wIC1wIHdhIC1rIHNlc3Npb24KCiMjIERpc2NyZXRpb25hcnkgQWNjZXNzIENvbnRyb2wgKERBQykgbW9kaWZpY2F0aW9ucwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBjaG1vZCAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGNob3duIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgZmNobW9kIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgZmNobW9kYXQgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBmY2hvd24gLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBmY2hvd25hdCAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGZyZW1vdmV4YXR0ciAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGZzZXR4YXR0ciAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGxjaG93biAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGxyZW1vdmV4YXR0ciAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGxzZXR4YXR0ciAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHJlbW92ZXhhdHRyIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgc2V0eGF0dHIgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBjaG1vZCAgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBjaG93biAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIGZjaG1vZCAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIGZjaG1vZGF0IC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgZmNob3duIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgZmNob3duYXQgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBmcmVtb3ZleGF0dHIgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBmc2V0eGF0dHIgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBsY2hvd24gLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBscmVtb3ZleGF0dHIgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBsc2V0eGF0dHIgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBwZXJtX21vZAotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyByZW1vdmV4YXR0ciAtRiBhdWlkPj0xMDAwIC1GIGF1aWQhPS0xIC1rIHBlcm1fbW9kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHNldHhhdHRyIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgcGVybV9tb2QKCiMgU3BlY2lhbCBSdWxlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMjIFJlY29ubmFpc3NhbmNlCi13IC91c3IvYmluL3dob2FtaSAtcCB4IC1rIHJlY29uCi13IC91c3IvYmluL2lkIC1wIHggLWsgcmVjb24KLXcgL2Jpbi9ob3N0bmFtZSAtcCB4IC1rIHJlY29uCi13IC9iaW4vdW5hbWUgLXAgeCAtayByZWNvbgotdyAvZXRjL2lzc3VlIC1wIHIgLWsgcmVjb24KLXcgL2V0Yy9ob3N0bmFtZSAtcCByIC1rIHJlY29uCgojIyBTdXNwaWNpb3VzIGFjdGl2aXR5Ci13IC91c3IvYmluL3dnZXQgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL2N1cmwgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL2Jhc2U2NCAtcCB4IC1rIHN1c3BfYWN0aXZpdHkKLXcgL2Jpbi9uYyAtcCB4IC1rIHN1c3BfYWN0aXZpdHkKLXcgL2Jpbi9uZXRjYXQgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL25jYXQgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL3NzaCAtcCB4IC1rIHN1c3BfYWN0aXZpdHkKLXcgL3Vzci9iaW4vc2NwIC1wIHggLWsgc3VzcF9hY3Rpdml0eQotdyAvdXNyL2Jpbi9zZnRwIC1wIHggLWsgc3VzcF9hY3Rpdml0eQotdyAvdXNyL2Jpbi9mdHAgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL3NvY2F0IC1wIHggLWsgc3VzcF9hY3Rpdml0eQotdyAvdXNyL2Jpbi93aXJlc2hhcmsgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL3RzaGFyayAtcCB4IC1rIHN1c3BfYWN0aXZpdHkKLXcgL3Vzci9iaW4vcmF3c2hhcmsgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC91c3IvYmluL3JkZXNrdG9wIC1wIHggLWsgc3VzcF9hY3Rpdml0eQotdyAvdXNyL2Jpbi9ubWFwIC1wIHggLWsgc3VzcF9hY3Rpdml0eQoKIyMgQWRkZWQgdG8gY2F0Y2ggbmV0Y2F0IG9uIFVidW50dQotdyAvYmluL25jLm9wZW5ic2QgLXAgeCAtayBzdXNwX2FjdGl2aXR5Ci13IC9iaW4vbmMudHJhZGl0aW9uYWwgLXAgeCAtayBzdXNwX2FjdGl2aXR5CgojIyBTYmluIHN1c3BpY2lvdXMgYWN0aXZpdHkKLXcgL3NiaW4vaXB0YWJsZXMgLXAgeCAtayBzYmluX3N1c3AKLXcgL3NiaW4vaXA2dGFibGVzIC1wIHggLWsgc2Jpbl9zdXNwCi13IC9zYmluL2lmY29uZmlnIC1wIHggLWsgc2Jpbl9zdXNwCi13IC91c3Ivc2Jpbi9hcnB0YWJsZXMgLXAgeCAtayBzYmluX3N1c3AKLXcgL3Vzci9zYmluL2VidGFibGVzIC1wIHggLWsgc2Jpbl9zdXNwCi13IC9zYmluL3h0YWJsZXMtbmZ0LW11bHRpIC1wIHggLWsgc2Jpbl9zdXNwCi13IC91c3Ivc2Jpbi9uZnQgLXAgeCAtayBzYmluX3N1c3AKLXcgL3Vzci9zYmluL3RjcGR1bXAgLXAgeCAtayBzYmluX3N1c3AKLXcgL3Vzci9zYmluL3RyYWNlcm91dGUgLXAgeCAtayBzYmluX3N1c3AKLXcgL3Vzci9zYmluL3VmdyAtcCB4IC1rIHNiaW5fc3VzcAoKIyMgZGJ1cy1zZW5kIGludm9jYXRpb24KIyMjIG1heSBpbmRpY2F0ZSBwcml2aWxlZ2UgZXNjYWxhdGlvbiBDVkUtMjAyMS0zNTYwCi13IC91c3IvYmluL2RidXMtc2VuZCAtcCB4IC1rIGRidXNfc2VuZAoKIyMgcGtleGVjIGludm9jYXRpb24KIyMjIG1heSBpbmRpY2F0ZSBwcml2aWxlZ2UgZXNjYWxhdGlvbiBDVkUtMjAyMS00MDM0Ci13IC91c3IvYmluL3BrZXhlYyAtcCB4IC1rIHBrZXhlYwoKIyMgU3VzcGljaW91cyBzaGVsbHMKIy13IC9iaW4vYXNoIC1wIHggLWsgc3VzcF9zaGVsbAojLXcgL2Jpbi9iYXNoIC1wIHggLWsgc3VzcF9zaGVsbAojLXcgL2Jpbi9jc2ggLXAgeCAtayBzdXNwX3NoZWxsCiMtdyAvYmluL2Rhc2ggLXAgeCAtayBzdXNwX3NoZWxsCiMtdyAvYmluL2J1c3lib3ggLXAgeCAtayBzdXNwX3NoZWxsCiMtdyAvYmluL2tzaCAtcCB4IC1rIHN1c3Bfc2hlbGwKIy13IC9iaW4vZmlzaCAtcCB4IC1rIHN1c3Bfc2hlbGwKIy13IC9iaW4vdGNzaCAtcCB4IC1rIHN1c3Bfc2hlbGwKIy13IC9iaW4vdGNsc2ggLXAgeCAtayBzdXNwX3NoZWxsCiMtdyAvYmluL3pzaCAtcCB4IC1rIHN1c3Bfc2hlbGwKCiMjIFNoZWxsL3Byb2ZpbGUgY29uZmlndXJhdGlvbnMKLXcgL2V0Yy9wcm9maWxlLmQvIC1wIHdhIC1rIHNoZWxsX3Byb2ZpbGVzCi13IC9ldGMvcHJvZmlsZSAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwotdyAvZXRjL3NoZWxscyAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwotdyAvZXRjL2Jhc2hyYyAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwotdyAvZXRjL2NzaC5jc2hyYyAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwotdyAvZXRjL2NzaC5sb2dpbiAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwotdyAvZXRjL2Zpc2gvIC1wIHdhIC1rIHNoZWxsX3Byb2ZpbGVzCi13IC9ldGMvenNoLyAtcCB3YSAtayBzaGVsbF9wcm9maWxlcwoKIyMgSW5qZWN0aW9uCiMjIyBUaGVzZSBydWxlcyB3YXRjaCBmb3IgY29kZSBpbmplY3Rpb24gYnkgdGhlIHB0cmFjZSBmYWNpbGl0eS4KIyMjIFRoaXMgY291bGQgaW5kaWNhdGUgc29tZW9uZSB0cnlpbmcgdG8gZG8gc29tZXRoaW5nIGJhZCBvciBqdXN0IGRlYnVnZ2luZwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBwdHJhY2UgLUYgYTA9MHg0IC1rIGNvZGVfaW5qZWN0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHB0cmFjZSAtRiBhMD0weDQgLWsgY29kZV9pbmplY3Rpb24KLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgcHRyYWNlIC1GIGEwPTB4NSAtayBkYXRhX2luamVjdGlvbgotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBwdHJhY2UgLUYgYTA9MHg1IC1rIGRhdGFfaW5qZWN0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHB0cmFjZSAtRiBhMD0weDYgLWsgcmVnaXN0ZXJfaW5qZWN0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHB0cmFjZSAtRiBhMD0weDYgLWsgcmVnaXN0ZXJfaW5qZWN0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIHB0cmFjZSAtayB0cmFjaW5nCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHB0cmFjZSAtayB0cmFjaW5nCgojIyBBbm9ueW1vdXMgRmlsZSBDcmVhdGlvbgojIyMgVGhlc2UgcnVsZXMgd2F0Y2ggdGhlIHVzZSBvZiBtZW1mZF9jcmVhdGUgCiMjIyAibWVtZmRfY3JlYXRlIiBjcmVhdGVzIGFub255bW91cyBmaWxlIGFuZCByZXR1cm5zIGEgZmlsZSBkZXNjcmlwdG9yIHRvIGFjY2VzcyBpdAojIyMgV2hlbiBjb21iaW5lZCB3aXRoICJmZXhlY3ZlIiBjYW4gYmUgdXNlZCB0byBzdGVhbHRoaWx5IHJ1biBiaW5hcmllcyBpbiBtZW1vcnkgd2l0aG91dCB0b3VjaGluZyBkaXNrICAKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgbWVtZmRfY3JlYXRlIC1GIGtleT1hbm9uX2ZpbGVfY3JlYXRlCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIG1lbWZkX2NyZWF0ZSAtRiBrZXk9YW5vbl9maWxlX2NyZWF0ZSAgICAgIAoKCiMjIFByaXZpbGVnZSBBYnVzZQojIyMgVGhlIHB1cnBvc2Ugb2YgdGhpcyBydWxlIGlzIHRvIGRldGVjdCB3aGVuIGFuIGFkbWluIG1heSBiZSBhYnVzaW5nIHBvd2VyIGJ5IGxvb2tpbmcgaW4gdXNlcidzIGhvbWUgZGlyLgotYSBhbHdheXMsZXhpdCAtRiBkaXI9L2hvbWUgLUYgdWlkPTAgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtQyBhdWlkIT1vYmpfdWlkIC1rIHBvd2VyX2FidXNlCgojIFNvZnR3YXJlIE1hbmFnZW1lbnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIFJQTSAoUmVkaGF0L0NlbnRPUykKIy13IC91c3IvYmluL3JwbSAtcCB4IC1rIHNvZnR3YXJlX21nbXQKIy13IC91c3IvYmluL3l1bSAtcCB4IC1rIHNvZnR3YXJlX21nbXQKCiMgRE5GIChGZWRvcmEvUmVkSGF0IDgvQ2VudE9TIDgpCiMtdyAvdXNyL2Jpbi9kbmYgLXAgeCAtayBzb2Z0d2FyZV9tZ210CgojIFlBU1QvWnlwcGVyL1JQTSAoU3VTRSkKIy13IC9zYmluL3lhc3QgLXAgeCAtayBzb2Z0d2FyZV9tZ210CiMtdyAvc2Jpbi95YXN0MiAtcCB4IC1rIHNvZnR3YXJlX21nbXQKIy13IC9iaW4vcnBtIC1wIHggLWsgc29mdHdhcmVfbWdtdAojLXcgL3Vzci9iaW4venlwcGVyIC1rIHNvZnR3YXJlX21nbXQKCiMgRFBLRyAvIEFQVC1HRVQgKERlYmlhbi9VYnVudHUpCiMtdyAvdXNyL2Jpbi9kcGtnIC1wIHggLWsgc29mdHdhcmVfbWdtdAojLXcgL3Vzci9iaW4vYXB0IC1wIHggLWsgc29mdHdhcmVfbWdtdAojLXcgL3Vzci9iaW4vYXB0LWFkZC1yZXBvc2l0b3J5IC1wIHggLWsgc29mdHdhcmVfbWdtdAojLXcgL3Vzci9iaW4vYXB0LWdldCAtcCB4IC1rIHNvZnR3YXJlX21nbXQKIy13IC91c3IvYmluL2FwdGl0dWRlIC1wIHggLWsgc29mdHdhcmVfbWdtdAojLXcgL3Vzci9iaW4vd2FqaWcgLXAgeCAtayBzb2Z0d2FyZV9tZ210CiMtdyAvdXNyL2Jpbi9zbmFwIC1wIHggLWsgc29mdHdhcmVfbWdtdAoKIyBQSVAgKFB5dGhvbiBpbnN0YWxscykKIy13IC91c3IvYmluL3BpcCAtcCB4IC1rIHNvZnR3YXJlX21nbXQKIy13IC91c3IvYmluL3BpcDMgLXAgeCAtayBzb2Z0d2FyZV9tZ210CgojIFNwZWNpYWwgU29mdHdhcmUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIyBHRFMgc3BlY2lmaWMgc2VjcmV0cwotdyAvZXRjL3B1cHBldC9zc2wgLXAgd2EgLWsgcHVwcGV0X3NzbAoKIyMgSUJNIEJpZ2ZpeCBCRVNDbGllbnQKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgb3BlbiAtRiBkaXI9L29wdC9CRVNDbGllbnQgLUYgc3VjY2Vzcz0wIC1rIHNvZnRfYmVzY2xpZW50Ci13IC92YXIvb3B0L0JFU0NsaWVudC8gLXAgd2EgLWsgc29mdF9iZXNjbGllbnQKCiMjIENIRUYgaHR0cHM6Ly93d3cuY2hlZi5pby9jaGVmLwotdyAvZXRjL2NoZWYgLXAgd2EgLWsgc29mdF9jaGVmCgojIyBEb2NrZXIKIy13IC91c3IvYmluL2RvY2tlcmQgLWsgZG9ja2VyCiMtdyAvdXNyL2Jpbi9kb2NrZXIgLWsgZG9ja2VyCiMtdyAvdXNyL2Jpbi9kb2NrZXItY29udGFpbmVyZCAtayBkb2NrZXIKIy13IC91c3IvYmluL2RvY2tlci1ydW5jIC1rIGRvY2tlcgojLXcgL3Zhci9saWIvZG9ja2VyIC1rIGRvY2tlcgojLXcgL2V0Yy9kb2NrZXIgLWsgZG9ja2VyCiMtdyAvZXRjL3N5c2NvbmZpZy9kb2NrZXIgLWsgZG9ja2VyCiMtdyAvZXRjL3N5c2NvbmZpZy9kb2NrZXItc3RvcmFnZSAtayBkb2NrZXIKIy13IC91c3IvbGliL3N5c3RlbWQvc3lzdGVtL2RvY2tlci5zZXJ2aWNlIC1rIGRvY2tlcgoKIyMgS3ViZWxldAotdyAvdXNyL2Jpbi9rdWJlbGV0IC1rIGt1YmVsZXQKCiMgSGlnaCBWb2x1bWUgRXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMjIFJlbW92ZSB0aGVtIGlmIHRoZXkgY2F1c2UgdG8gbXVjaCB2b2x1bWUgaW4geW91ciBlbnZpcm9ubWVudAoKIyMgUm9vdCBjb21tYW5kIGV4ZWN1dGlvbnMKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLUYgZXVpZD0wIC1TIGV4ZWN2ZSAtayByb290Y21kCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1GIGV1aWQ9MCAtUyBleGVjdmUgLWsgcm9vdGNtZAoKIyMgRmlsZSBEZWxldGlvbiBFdmVudHMgYnkgVXNlcgotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBybWRpciAtUyB1bmxpbmsgLVMgdW5saW5rYXQgLVMgcmVuYW1lIC1TIHJlbmFtZWF0IC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgZGVsZXRlCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHJtZGlyIC1TIHVubGluayAtUyB1bmxpbmthdCAtUyByZW5hbWUgLVMgcmVuYW1lYXQgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBkZWxldGUKCiMjIEZpbGUgQWNjZXNzCiMjIyBVbmF1dGhvcml6ZWQgQWNjZXNzICh1bnN1Y2Nlc3NmdWwpCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGNyZWF0IC1TIG9wZW4gLVMgb3BlbmF0IC1TIG9wZW5fYnlfaGFuZGxlX2F0IC1TIHRydW5jYXRlIC1TIGZ0cnVuY2F0ZSAtRiBleGl0PS1FQUNDRVMgLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBmaWxlX2FjY2VzcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyBjcmVhdCAtUyBvcGVuIC1TIG9wZW5hdCAtUyBvcGVuX2J5X2hhbmRsZV9hdCAtUyB0cnVuY2F0ZSAtUyBmdHJ1bmNhdGUgLUYgZXhpdD0tRVBFUk0gLUYgYXVpZD49MTAwMCAtRiBhdWlkIT0tMSAtayBmaWxlX2FjY2VzcwotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBjcmVhdCAtUyBvcGVuIC1TIG9wZW5hdCAtUyBvcGVuX2J5X2hhbmRsZV9hdCAtUyB0cnVuY2F0ZSAtUyBmdHJ1bmNhdGUgLUYgZXhpdD0tRUFDQ0VTIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgZmlsZV9hY2Nlc3MKLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgY3JlYXQgLVMgb3BlbiAtUyBvcGVuYXQgLVMgb3Blbl9ieV9oYW5kbGVfYXQgLVMgdHJ1bmNhdGUgLVMgZnRydW5jYXRlIC1GIGV4aXQ9LUVQRVJNIC1GIGF1aWQ+PTEwMDAgLUYgYXVpZCE9LTEgLWsgZmlsZV9hY2Nlc3MKCiMjIyBVbnN1Y2Nlc3NmdWwgQ3JlYXRpb24KLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgY3JlYXQsbGluayxta25vZCxta2RpcixzeW1saW5rLG1rbm9kYXQsbGlua2F0LHN5bWxpbmthdCAtRiBleGl0PS1FQUNDRVMgLWsgZmlsZV9jcmVhdGlvbgotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyBta2RpcixjcmVhdCxsaW5rLHN5bWxpbmssbWtub2QsbWtub2RhdCxsaW5rYXQsc3ltbGlua2F0IC1GIGV4aXQ9LUVBQ0NFUyAtayBmaWxlX2NyZWF0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjMyIC1TIGxpbmssbWtkaXIsc3ltbGluayxta2RpcmF0IC1GIGV4aXQ9LUVQRVJNIC1rIGZpbGVfY3JlYXRpb24KLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iNjQgLVMgbWtkaXIsbGluayxzeW1saW5rLG1rZGlyYXQgLUYgZXhpdD0tRVBFUk0gLWsgZmlsZV9jcmVhdGlvbgoKIyMjIFVuc3VjY2Vzc2Z1bCBNb2RpZmljYXRpb24KLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgcmVuYW1lIC1TIHJlbmFtZWF0IC1TIHRydW5jYXRlIC1TIGNobW9kIC1TIHNldHhhdHRyIC1TIGxzZXR4YXR0ciAtUyByZW1vdmV4YXR0ciAtUyBscmVtb3ZleGF0dHIgLUYgZXhpdD0tRUFDQ0VTIC1rIGZpbGVfbW9kaWZpY2F0aW9uCi1hIGFsd2F5cyxleGl0IC1GIGFyY2g9YjY0IC1TIHJlbmFtZSAtUyByZW5hbWVhdCAtUyB0cnVuY2F0ZSAtUyBjaG1vZCAtUyBzZXR4YXR0ciAtUyBsc2V0eGF0dHIgLVMgcmVtb3ZleGF0dHIgLVMgbHJlbW92ZXhhdHRyIC1GIGV4aXQ9LUVBQ0NFUyAtayBmaWxlX21vZGlmaWNhdGlvbgotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWIzMiAtUyByZW5hbWUgLVMgcmVuYW1lYXQgLVMgdHJ1bmNhdGUgLVMgY2htb2QgLVMgc2V0eGF0dHIgLVMgbHNldHhhdHRyIC1TIHJlbW92ZXhhdHRyIC1TIGxyZW1vdmV4YXR0ciAtRiBleGl0PS1FUEVSTSAtayBmaWxlX21vZGlmaWNhdGlvbgotYSBhbHdheXMsZXhpdCAtRiBhcmNoPWI2NCAtUyByZW5hbWUgLVMgcmVuYW1lYXQgLVMgdHJ1bmNhdGUgLVMgY2htb2QgLVMgc2V0eGF0dHIgLVMgbHNldHhhdHRyIC1TIHJlbW92ZXhhdHRyIC1TIGxyZW1vdmV4YXR0ciAtRiBleGl0PS1FUEVSTSAtayBmaWxlX21vZGlmaWNhdGlvbgoKIyMgMzJiaXQgQVBJIEV4cGxvaXRhdGlvbgojIyMgSWYgeW91IGFyZSBvbiBhIDY0IGJpdCBwbGF0Zm9ybSwgZXZlcnl0aGluZyBfc2hvdWxkXyBiZSBydW5uaW5nCiMjIyBpbiA2NCBiaXQgbW9kZS4gVGhpcyBydWxlIHdpbGwgZGV0ZWN0IGFueSB1c2Ugb2YgdGhlIDMyIGJpdCBzeXNjYWxscwojIyMgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGEgc2lnbiBvZiBzb21lb25lIGV4cGxvaXRpbmcgYSBob2xlIGluIHRoZSAzMgojIyMgYml0IEFQSS4KLWEgYWx3YXlzLGV4aXQgLUYgYXJjaD1iMzIgLVMgYWxsIC1rIDMyYml0X2FwaQoKIyBNYWtlIFRoZSBDb25maWd1cmF0aW9uIEltbXV0YWJsZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMtZSAyCg=='
                    for instance_id in instance_ids:
                        try:
                            logging.info(f'CONFIGURING OS INTERNALS ON INSTANCE-ID: {instance_id}')
                            response = ssm_client.send_command(
                                InstanceIds = [instance_id],
                                DocumentName = "AWS-RunShellScript",
                                Parameters = {'commands': ['apt-get update -y','apt-get install -y auditd','systemctl kill auditd.service', 'sleep 10', f'echo {auditd_rules} | base64 --decode > "/etc/audit/rules.d/audit.rules"', 'sleep 10','systemctl start auditd.service'] }
                            )
                            logging.info(f'COMMAND SUCCEEDED.')
                        except Exception as e:
                            pass
                except Exception as e:
                    logging.critical(str(e))

            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STRATING CYNGULARS FUNCTION...')

                LAMBDA_NAME = context.function_name
                REGIONS = os.environ['CLIENT_REGIONS']
                try:
                    if os.environ.get('FIRST_RUN') == 'true':
                        logger.info('First run detected. Updating EventBridge rule schedule.')
                        try:
                            lambda_client = boto3.client('lambda')
                            events_client = boto3.client('events')
                            response = events_client.put_rule(
                                Name = f"{LAMBDA_NAME}-rule",
                                State='ENABLED',
                                ScheduleExpression = os.environ['FINAL_CRON'],
                                Description = 'LambdaOS | Config OS | Scheduled to run daily',
                                EventBusName = 'default'
                            )
                            logger.info('Successfully updated the EventBridge rule: %s', response)
                            response = lambda_client.update_function_configuration(
                                FunctionName = LAMBDA_NAME,
                                Environment = {'Variables': {"FIRST_RUN": "false", "CLIENT_REGIONS": REGIONS}}
                            )
                            logger.info('Successfully updated the function configuration: %s', response)
                        except Exception as e:
                            logger.critical('Error updating the EventBridge rule: %s', str(e))
                            raise

                    for curr_region in REGIONS.split(' '):
                        logger.info(f'Current AWS REGION: {curr_region}')
                        try:
                            osinternals(curr_region)
                        except Exception as e:
                            logger.critical(str(e))                  
                    logger.info('DONE!')

                except Exception as e:
                    logger.critical(str(e))
      Tags:
        - Key: Name
          Value: "cyngular-lambda-config-os"
        - Key: Vendor
          Value: "Cyngular Security"

  ScheduledRuleLambdaOS:
    Type: AWS::Events::Rule
    DependsOn: [StackSetManagerTrigger]
    Properties:
      Name: !Sub "${LambdaOS}-rule"
      Description: "Function did not run yet"
      ScheduleExpression: "rate(2 minutes)"
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaOS.Arn
          Id: "TargetFunctionV1"

  PermissionForEventsToInvokeLambdaOS:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LambdaOS
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt ScheduledRuleLambdaOS.Arn

  LambdaEKS:
    Type: AWS::Lambda::Function
    Condition: ServiceEKS
    Properties:
      FunctionName: "cyngular-lambda-config-eks"
      Description: "Created by Cyngular Security | Configure EKS Logging"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Join [" ", !Ref ClientRegions]
          FINAL_CRON: "cron(0 * * * ? *)"
          FIRST_RUN: "true"
          ROLE_ARN: !GetAtt ClientCyngularRole.Arn

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 900
      Code:
        ZipFile: |
            import boto3
            import traceback
            import os
            import logging
            from botocore.exceptions import ClientError

            def check_access_entry_exists(eks_client, cluster_name, role_arn):
                try:
                    response = eks_client.list_access_entries(clusterName=cluster_name)
                    if 'accessEntries' in response:
                        return role_arn in response['accessEntries']
                    return False
                except eks_client.exceptions.ResourceNotFoundException:
                    logging.error(f'Cluster {cluster_name} not found')
                    return False
                except ClientError as e:
                    if e.response['Error']['Code'] == 'InvalidRequestException' and 'authentication mode' in str(e):
                        logging.warning(f'Cluster {cluster_name} has incompatible authentication mode for access entries')
                        return False
                except Exception as e:
                    logging.error(f'Error checking access entries: {str(e)}')
                    return False

            def create_access_entry(eks_client, logger, cluster_name, role_arn):
                try:
                    try:
                        cluster_info = eks_client.describe_cluster(name=cluster_name)
                        auth_mode = cluster_info['cluster'].get('accessConfig', {}).get('authenticationMode', 'CONFIG_MAP')
                        if auth_mode not in ['API', 'API_AND_CONFIG_MAP']:
                            logger.warning(f'Skipping access entry creation for cluster {cluster_name} - incompatible authentication mode: {auth_mode}')
                            return
                    except Exception as e:
                        logger.error(f'Error checking cluster authentication mode: {str(e)}')
                        return

                    if check_access_entry_exists(eks_client, cluster_name, role_arn):
                        logger.info(f'Access entry for role {role_arn} already exists in cluster {cluster_name}.')
                        return

                    logger.info(f'Creating access entry for cluster: {cluster_name}')
                    response = eks_client.create_access_entry(
                        clusterName=cluster_name,
                        principalArn=role_arn,
                        type='STANDARD'
                    )
                    logger.info(f'Access entry created successfully: {response["accessEntry"]["accessEntryArn"]}')

                    logger.info(f'Associating access policy for cluster: {cluster_name}')
                    eks_client.associate_access_policy(
                        clusterName=cluster_name,
                        principalArn=role_arn,
                        policyArn='arn:aws:eks::aws:cluster-access-policy/AmazonEKSViewPolicy',
                        accessScope={
                            'type': 'cluster'
                        }
                    )
                    logger.info('Access policy associated successfully')
                except eks_client.exceptions.ResourceNotFoundException as e_not_found:
                    logger.error(f'Cluster {cluster_name} not found -- {str(e_not_found)}')
                except eks_client.exceptions.AccessDeniedException as e_access_denied:
                    logger.error(f'Access denied when creating access entry for cluster {cluster_name} -- {str(e_access_denied)}')
                except Exception as e:
                    logger.error(f'Error creating access entry: {str(e)}')

            def ekslogs(curr_region, logger, role_arn):
                try:
                    logger.info('STARTING EKSLOGS...')
                    wanted_cluster_logging_config = {
                        'clusterLogging': [{
                            'types': ['audit', 'authenticator'],
                            'enabled': True
                        }]
                    }
                    eks_client = boto3.client('eks', region_name=curr_region)
                    logger.info('EKS client created successfully')
                    
                    clusters = eks_client.list_clusters()['clusters']
                    logger.info(f'Found {len(clusters)} clusters in region {curr_region}')

                    for cluster_name in clusters:
                        try:
                            logger.info(f'CONFIGURING EKSLOGS ON CLUSTER: {cluster_name}')
                            eks_client.update_cluster_config(
                                name=cluster_name,
                                logging=wanted_cluster_logging_config
                            )
                            logger.info(f'COMMAND SUCCEEDED.')
                            
                        except Exception as e:
                            if 'No changes needed for the logging config provided' not in str(e):
                                logger.critical(f'COMMAND FAILED - {str(e)}')
                            else:
                                logger.info(f'No changes needed for cluster {cluster_name}')
                
                        create_access_entry(eks_client, logger, cluster_name, role_arn)

                except Exception as e:
                    logger.critical(f'Error in ekslogs function: {str(e)}')
                    logger.critical(traceback.format_exc())
                    
            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STARTING CYNGULARS FUNCTION...')

                LAMBDA_NAME = context.function_name
                REGIONS = os.environ['CLIENT_REGIONS']
                ROLE_ARN = os.environ['ROLE_ARN']
                try:
                    if os.environ.get('FIRST_RUN') == 'true':
                        logger.info('First run detected. Updating EventBridge rule schedule.')
                        try:
                            lambda_client = boto3.client('lambda')
                            events_client = boto3.client('events')
                            response = events_client.put_rule(
                                Name=f"{LAMBDA_NAME}-rule",
                                State='ENABLED',
                                ScheduleExpression=os.environ['FINAL_CRON'],
                                Description='LambdaEKS | Scheduled to run hourly',
                                EventBusName='default'
                            )
                            logger.info('Successfully updated the EventBridge rule: %s', response)
                            response = lambda_client.update_function_configuration(
                                FunctionName=LAMBDA_NAME,
                                Environment={'Variables': {"FIRST_RUN": "false", "CLIENT_REGIONS": REGIONS, "ROLE_ARN": ROLE_ARN}}
                            )
                            logger.info('Successfully updated the function configuration: %s', response)
                        except Exception as e:
                            logger.critical('Error updating the EventBridge rule: %s', str(e))
                            raise

                    logger.info('STARTING EKSLOGS...')                    
                    for curr_region in REGIONS.split(' '):
                        logger.info(f'AWS REGION: {curr_region}')
                        try:
                            ekslogs(curr_region, logger, ROLE_ARN)
                        except Exception as e:
                            logger.critical(str(e))
                    logger.info('DONE!')
                    return {
                        'statusCode': 200,
                        'body': 'Function executed successfully'
                    }

                except Exception as e:
                    logger.critical(str(e))
                    return {
                        'statusCode': 500,
                        'body': f'Error occurred: {str(e)}'
                    }
      Tags:
        - Key: Name
          Value: "cyngular-lambda-config-eks"
        - Key: Vendor
          Value: "Cyngular Security"

  ScheduledRuleLambdaEKS:
    Type: AWS::Events::Rule
    DependsOn: [StackSetManagerTrigger]
    Condition: ServiceEKS
    Properties:
      Name: !Sub "${LambdaEKS}-rule"
      Description: "Function did not run yet"
      ScheduleExpression: "rate(2 minutes)"
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaEKS.Arn
          Id: "TargetFunctionV1"

  PermissionForEventsToInvokeLambdaEKS: 
    Type: AWS::Lambda::Permission
    Condition: ServiceEKS
    Properties: 
      FunctionName: !Ref LambdaEKS
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt ScheduledRuleLambdaEKS.Arn

  LambdaDNS:
    Type: AWS::Lambda::Function
    Condition: ServiceDNS
    Properties:
      FunctionName: "cyngular-lambda-config-dns"
      Description: "Created by Cyngular Security. | Configure DNS"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Join [" ", !Ref ClientRegions]
          FINAL_CRON: "cron(0 * * * ? *)"
          FIRST_RUN: "true"

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 900
      Code:
        ZipFile: |
            import boto3
            import traceback
            import os
            import logging

            def dnslogs(curr_region):
                try:
                    logging.info(f'STARTING DNSLOGS...')
                    r_53_client = boto3.client('route53resolver', region_name=curr_region)
                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    
                    region_query_log_configs = r_53_client.list_resolver_query_log_configs()['ResolverQueryLogConfigs']
                    cyngular_resolver_id = ''
                    
                    for region_query_log_config in region_query_log_configs:
                        try:
                            if region_query_log_config['Name'] == 'cyngular_dns':
                                cyngular_resolver_id = region_query_log_config['Id']
                                break
                        except:
                            pass

                    if cyngular_resolver_id:
                        vpc_list = ec2_client.describe_vpcs()
                        if "Vpcs" in vpc_list:                  
                            for vpc in vpc_list["Vpcs"]:
                                try:
                                    vpc_id = vpc["VpcId"]
                                    logging.info(f'CONFIGURING DNSLOGS ON VPC-ID: {vpc_id}')
                                    resp = r_53_client.associate_resolver_query_log_config(ResolverQueryLogConfigId = cyngular_resolver_id, ResourceId = vpc_id )
                                    logging.info(f'COMMAND SUCCEEDED.')
                                except Exception as e:
                                    if not 'already associated' in str(e):
                                        logging.critical(str(e))
                except Exception as e:
                    logging.critical(str(e))

            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STRATING CYNGULARS FUNCTION...')

                LAMBDA_NAME=context.function_name
                REGIONS=os.environ['CLIENT_REGIONS']
                try:
                    if os.environ.get('FIRST_RUN') == 'true':
                        logger.info('First run detected. Updating EventBridge rule schedule.')
                        try:
                            lambda_client = boto3.client('lambda')
                            events_client = boto3.client('events')
                            response = events_client.put_rule(
                                Name = f"{LAMBDA_NAME}-rule",
                                State = 'ENABLED',
                                ScheduleExpression = os.environ['FINAL_CRON'],
                                Description = 'LambdaDNS | Scheduled to run hourly',
                                EventBusName = 'default'
                            )
                            logger.info('Successfully updated the EventBridge rule: %s', response)
                            response = lambda_client.update_function_configuration(
                                FunctionName=LAMBDA_NAME,
                                Environment={'Variables': {"FIRST_RUN": "false", "CLIENT_REGIONS": REGIONS}}
                            )
                            logger.info('Successfully updated the function configuration: %s', response)
                        except Exception as e:
                            logger.critical('Error updating the EventBridge rule: %s', str(e))
                            raise

                    logger.info('STARTING DNSLOGS...')                    
                    for curr_region in REGIONS.split(' '):
                        logging.info(f'AWS REGION: {curr_region}')
                        try:
                            dnslogs(curr_region)
                        except Exception as e:
                            logging.critical(str(e))
                    logging.info('DONE!')

                except Exception as e:
                    logging.critical(str(e))
      Tags:
        - Key: Name
          Value: "cyngular-lambda-config-dns"
        - Key: Vendor
          Value: "Cyngular Security"

  ScheduledRuleLambdaDNS: 
    Type: AWS::Events::Rule
    DependsOn: [StackSetManagerTrigger]
    Condition: ServiceDNS
    Properties:
      Name: !Sub "${LambdaDNS}-rule"
      Description: "Function did not run yet"
      ScheduleExpression: "rate(2 minutes)"
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaDNS.Arn
          Id: "TargetFunctionV1"

  PermissionForEventsToInvokeLambdaDNS: 
    Type: AWS::Lambda::Permission
    Condition: ServiceDNS
    Properties: 
      FunctionName: !Ref LambdaDNS
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt ScheduledRuleLambdaDNS.Arn

  LambdaVFL:
    Type: AWS::Lambda::Function
    Condition: ServiceVFL
    Properties:
      FunctionName: "cyngular-lambda-config-vpcflowlogs"
      Description: "Created by Cyngular Security. | Configure VFL"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Join [" ", !Ref ClientRegions]
          FINAL_CRON: "cron(0 * * * ? *)"
          FIRST_RUN: "true"
          CYNGULAR_BUCKET: !Ref CyngularS3Bucket

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 900
      Code:
        ZipFile: | 
            import boto3
            import traceback
            import os
            import logging

            def vpcflowlogs(curr_region, bucket_name):
                try:
                    logging.info('STARTING VPCFLOWLOGS...')

                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    vpc_list = ec2_client.describe_vpcs()

                    vpc_id_list = []
                    if "Vpcs" in vpc_list:                  
                        for vpc in vpc_list["Vpcs"]:
                            vpc_id_list.append(vpc["VpcId"])

                    logging.info(f'CONFIGURING VPCFLOWLOGS ON VPC-IDS: {vpc_id_list}')
                    response = ec2_client.create_flow_logs(
                        ResourceIds=vpc_id_list,
                        ResourceType='VPC',
                        TrafficType='ALL',
                        LogDestinationType = 's3',
                        LogDestination = f"arn:aws:s3:::{bucket_name}",
                        TagSpecifications=[
                            {
                                'ResourceType': 'vpc-flow-log',
                                'Tags': [
                                    {
                                        'Key': 'Name',
                                        'Value': 'Cyngular-vpc-flowlogs'
                                    },
                                ]
                            },
                        ]
                    )
                    logging.info(f'COMMAND SUCCEEDED.')

                except Exception as e:
                    if 'FlowLogAlreadyExists' in str(e):
                        pass
                    else:
                        logging.critical(str(e))

            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STRATING CYNGULARS FUNCTION...')

                LAMBDA_NAME = context.function_name
                REGIONS = os.environ['CLIENT_REGIONS']
                bucket_name = os.environ['CYNGULAR_BUCKET']
                try:
                    if os.environ.get('FIRST_RUN') == 'true':
                        logger.info('First run detected. Updating EventBridge rule schedule.')
                        try:
                            lambda_client = boto3.client('lambda')
                            events_client = boto3.client('events')
                            response = events_client.put_rule(
                                Name = f"{LAMBDA_NAME}-rule",
                                State = 'ENABLED',
                                ScheduleExpression = os.environ['FINAL_CRON'],
                                Description = 'LambdaVFL | Scheduled to run hourly',
                                EventBusName = 'default'
                            )
                            logger.info('Successfully updated the EventBridge rule: %s', response)
                            response = lambda_client.update_function_configuration(
                                FunctionName=LAMBDA_NAME,
                                Environment={'Variables': {"FIRST_RUN": "false", "CLIENT_REGIONS": REGIONS, "CYNGULAR_BUCKET": bucket_name}}
                            )
                            logger.info('Successfully updated the function configuration: %s', response)
                        except Exception as e:
                            logger.critical('Error updating the EventBridge rule: %s', str(e))
                            raise

                    logger.info('STARTING VPCFLOWLOGS...')
                    for curr_region in REGIONS.split(' '):
                        logging.info(f'AWS REGION: {curr_region}')
                        try:
                            vpcflowlogs(curr_region, bucket_name)
                        except Exception as e:
                            logging.critical(str(e))
                    logging.info('DONE!')

                except Exception as e:
                    logging.critical(str(e))
      Tags:
        - Key: Name
          Value: "cyngular-lambda-config-vpcflowlogs"
        - Key: Vendor
          Value: "Cyngular Security"

  ScheduledRuleLambdaVFL:
    Type: AWS::Events::Rule
    DependsOn: [StackSetManagerTrigger]
    Condition: ServiceVFL
    Properties: 
      Name: !Sub "${LambdaVFL}-rule"
      Description: "Function did not run yet"
      ScheduleExpression: "rate(2 minutes)"
      State: "ENABLED"
      Targets: 
        - Arn: !GetAtt LambdaVFL.Arn
          Id: "TargetFunctionV1"

  PermissionForEventsToInvokeLambdaVFL: 
    Type: AWS::Lambda::Permission
    Condition: ServiceVFL
    Properties:
      FunctionName: !Ref LambdaVFL
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt ScheduledRuleLambdaVFL.Arn

  LambdaRemoveVFL:
    Type: AWS::Lambda::Function
    Condition: ServiceVFL
    Properties:
      FunctionName: "cyngular-lambda-remove-vpcflowlogs"
      Description: "Created by Cyngular Security. | Remove VPCFLOWLOGS"
      Role: !GetAtt LambdasRole.Arn

      Environment:
        Variables:
          CLIENT_REGIONS: !Join [" ", !Ref ClientRegions]

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 900
      Code:
        ZipFile: | 
            import boto3
            import traceback
            import os
            import logging

            def vpcflowlogs(curr_region):
                try:
                    logging.info('DELETING VPCFLOWLOGS...')

                    flowlogs_ids_list = []
                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    
                    response = ec2_client.describe_flow_logs(
                        Filters=[
                            {
                                'Name': 'tag:Name',
                                'Values': [
                                    'Cyngular-vpc-flowlogs'
                                ]
                            },
                        ]
                    )
                    for flow_log in response['FlowLogs']:
                        flowlogs_ids_list.append(flow_log['FlowLogId'])
                    
                    logging.info(f'DELETING THE VPCFLOWLOGS: {flowlogs_ids_list}')
                    response = ec2_client.delete_flow_logs(
                        FlowLogIds=flowlogs_ids_list
                    )
                    logging.info(f'COMMAND SUCCEEDED.')
                except Exception as e:
                    logging.critical(str(e))
                    
            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                try:
                    logger.info('STRATING CYNGULARS FUNCTION...')
                    events_client = boto3.client('events')
                    REGIONS = os.environ['CLIENT_REGIONS']

                    for curr_region in REGIONS.split(' '):
                        logger.info(f'AWS REGION: {curr_region}')
                        try:
                            vpcflowlogs(curr_region)
                        except Exception as e:
                            logger.critical(str(e))
                    logger.info('DEACTIVATING EVENT BUS RULE')
                    response = events_client.disable_rule(
                        Name='cyngular-lambda-config-vpcflowlogs-rule',
                        EventBusName='default'
                    )
                    logger.info('DONE!')
                except Exception as e:
                    logger.critical(str(e))
      Tags:
        - Key: Name
          Value: "cyngular-lambda-remove-vpcflowlogs"
        - Key: Vendor
          Value: "Cyngular Security"

  LambdaRemoveDNS:
    Type: AWS::Lambda::Function
    Condition: ServiceDNS
    Properties:
      FunctionName: "cyngular-lambda-remove-dns"
      Description: "Created by Cyngular Security. | Remove DNS"
      Role: !GetAtt LambdasRole.Arn

      Environment:
        Variables:
          CLIENT_REGIONS: !Join [" ", !Ref ClientRegions]

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 900
      Code:
        ZipFile: | 
            import boto3
            import traceback
            import os
            import logging
            
            def dnslogs(curr_region):
                try:
                    r_53_client = boto3.client('route53resolver', region_name=curr_region)
                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    
                    region_query_log_configs = r_53_client.list_resolver_query_log_configs()['ResolverQueryLogConfigs']
                    cyngular_resolver_id = ''
                    
                    for region_query_log_config in region_query_log_configs:
                        try:
                            if region_query_log_config['Name'] == 'cyngular_dns':
                                cyngular_resolver_id = region_query_log_config['Id']
                                break
                        except:
                            pass

                    if cyngular_resolver_id:
                        vpc_list = ec2_client.describe_vpcs()
                        if "Vpcs" in vpc_list:                  
                            for vpc in vpc_list["Vpcs"]:
                                try:
                                    vpc_id = vpc["VpcId"]
                                    logging.info (f'DELETING CONFIGURATION OF DNSLOGS ON VPC-ID: {vpc_id}')
                                    resp = r_53_client.disassociate_resolver_query_log_config(ResolverQueryLogConfigId = cyngular_resolver_id, ResourceId = vpc_id )
                                    logging.info(f'COMMAND SUCCEEDED.')
                                except Exception as e:
                                    if "association doesn't exist" in str(e):
                                        logging.critical(f'{vpc_id} - ResolverWasNotAssociated')
                                    else:
                                        logging.critical(str(e))
                except Exception as e:
                    logging.critical(str(e))

            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                try:
                    logger.info ('STRATING CYNGULARS FUNCTION...')
                    logger.info(f'DELETING DNSLOGS...')
                    events_client = boto3.client('events')
                    REGIONS = os.environ['CLIENT_REGIONS']

                    for curr_region in REGIONS.split(' '):
                        logger.info(f'AWS REGION: {curr_region}')
                        try:
                            dnslogs(curr_region)
                        except Exception as e:
                            logger.critical(str(e))
                    logger.info('DEACTIVATING EVENT BUS RULE')
                    response = events_client.disable_rule(
                        Name='cyngular-lambda-config-dns-rule',
                        EventBusName='default'
                    )
                    logger.info('DONE!')

                except Exception as e:
                    logger.critical(str(e))
      Tags:
        - Key: Name
          Value: "cyngular-lambda-remove-dns"
        - Key: Vendor
          Value: "Cyngular Security"

  LambdaUpdateCyngularBucketPolicy:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "cyngular-lambda-update-cyngular-bucket-policy"
      Description: Created by Cyngular Security.
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          BUCKET_NAME: !Ref CyngularS3Bucket

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 900
      Code:
        ZipFile: | 
            import boto3
            import traceback
            import os
            import logging
            import json

            def get_account_ids_lst(management_account_id):
                child_accounts = []
                try:
                    org_client = boto3.client('organizations')
                    paginator = org_client.get_paginator('list_accounts')

                    for page in paginator.paginate():
                        child_accounts.extend(
                            account['Id'] for account in page['Accounts'] if account['Id'] != management_account_id
                        )                
                except Exception as e:
                    logging.critical("CloudServiceFunctions (ERROR) - while trying to get account ids for organization: " + str(e))
                return child_accounts

            def update_bucket(bucket_name, management_account_id):
                try:
                    s3_client=boto3.client('s3')
                    response=s3_client.get_bucket_policy(
                        Bucket=bucket_name
                    )
                    
                    account_ids_list=get_account_ids_lst(management_account_id)
                    account_arns_list=[]
                    for account_id in account_ids_list:
                        account_arns_list.append(f"\"arn:aws:logs:*:{account_id}:*\"")
                    new_statement = '''[
                        {
                            "Sid": "OrgLogDeliveryWrite",
                            "Effect": "Allow",
                            "Principal": {
                                "Service": "delivery.logs.amazonaws.com"
                            },
                            "Action": "s3:PutObject",
                            "Resource": "$%BUCKET_ARN%$/*",
                            "Condition": {
                                "ArnLike": {
                                    "AWS:SourceArn": [$%ACCOUNT_ARNS_LIST%$]
                                }
                            }
                        },
                        {
                            "Sid": "OrgLogDeliveryAclCheck",
                            "Effect": "Allow",
                            "Principal": {
                                "Service": "delivery.logs.amazonaws.com"
                            },
                            "Action": [
                                "s3:GetBucketAcl",
                                "s3:ListBucket"
                            ],
                            "Resource": "$%BUCKET_ARN%$",
                            "Condition": {
                                "ArnLike": {
                                    "aws:SourceArn": [$%ACCOUNT_ARNS_LIST%$]
                                }
                            }
                        }
                    ]
                    '''.replace('$%ACCOUNT_ARNS_LIST%$', ','.join(account_arns_list)).replace('$%BUCKET_ARN%$', f"arn:aws:s3:::{bucket_name}")
                    new_statement_json=json.loads(new_statement)
                    reponse_policy=json.loads(response['Policy'])
                    statement_policy=reponse_policy['Statement']
                    statement_policy.extend(new_statement_json)
                    new_policy = {}
                    new_policy['Statement']=statement_policy
                    new_policy['Version']='2012-10-17'

                    response=s3_client.put_bucket_policy(
                        Bucket=bucket_name,
                        Policy=json.dumps(new_policy)
                    )
                    logging.info(response)
                except Exception as e:
                    logging.critical(str(e))
                
            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STARTING CYNGULAR\'S FUNCTION...')
                try:
                    logger.info('UPDATING CYNGULAR BUCKET POLICY')
                    cyngular_bucket_name = os.environ['BUCKET_NAME']
                    mgmt_acc_id = boto3.client('sts').get_caller_identity()['Account']

                    update_bucket(cyngular_bucket_name, mgmt_acc_id)
                    logger.info('DONE!')

                except Exception as e:
                    logger.critical(str(e))
      Tags:
        - Key: Name
          Value: "cyngular-lambda-update-cyngular-bucket-policy"
        - Key: Vendor
          Value: "Cyngular Security"

  AdminAndExecTrigger:
    Type: Custom::AdminAndExec
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain

    Version: "1.0"
    Properties:
      ServiceToken: !GetAtt LambdaAdminAndExec.Arn
      ServiceTimeout: 1200

      ADMIN_TEMPLATE_URL: !Sub
        - "https://${bucket_name}.s3.amazonaws.com/stacks/AWSCloudFormationStackSetAdministrationRole.yaml"
        - bucket_name: !FindInMap [VARS, Cyngular, TemplateBucket]

      EXEC_TEMPLATE_URL: !Sub
        - "https://${bucket_name}.s3.amazonaws.com/stacks/AWSCloudFormationStackSetExecutionRole.yaml"
        - bucket_name: !FindInMap [VARS, Cyngular, TemplateBucket]

  LambdaAdminAndExec:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "cyngular-lambda-admin-and-execution-roles"
      Description: Created by Cyngular Security.

      Role: !GetAtt LambdaAdminAndExecRole.Arn
      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 900
      Environment:
        Variables:
          CLIENT_REGIONS: !Join [",", !Ref ClientRegions]
          IsOrg: !If [IsOrg, true, false]

      Code:
        ZipFile: |
            import boto3
            import time
            import os
            import cfnresponse
            import logging
            import botocore

            def check_role_existence_in_child(account_id, role_name='AWSCloudFormationStackSetExecutionRole'):
                sts_client = boto3.client('sts')
                role_arn = f'arn:aws:iam::{account_id}:role/{role_name}'
                try:
                    # Attempt to assume the role in the child account
                    assumed_role = sts_client.assume_role(
                        RoleArn=role_arn,
                        RoleSessionName='CheckRoleSession'
                    )
                    
                    # If assume_role is successful, the role exists and is assumable
                    logging.info(f"Successfully assumed role '{role_name}' in account {account_id}.")
                    return True

                except botocore.exceptions.ClientError as e:
                    error_code = e.response['Error']['Code']
                    if error_code == 'AccessDenied':
                        # Role exists, but we can't assume it (which is expected)
                        logging.info(f"Role '{role_name}' exists in account {account_id}, but cannot be assumed as expected.")
                        return True
                    elif error_code == 'NoSuchEntity':
                        # Role doesn't exist
                        logging.info(f"Role '{role_name}' does not exist in account {account_id}.")
                        return False
                    else:
                        # Some other error occurred
                        logging.info(f"Unexpected error checking role in account {account_id}: {e}")
                        return False

            def check_role_existence(role_name):
                iam_client = boto3.client('iam')
                try:
                    iam_client.get_role(RoleName=role_name)
                    logging.info(f"The IAM role '{role_name}' exists.")
                    return True
                except Exception as e:
                    logging.info(str(e))
                    return False

            def wait_for(stack_name):
                cfn_client = boto3.client('cloudformation')
                waiter = cfn_client.get_waiter('stack_create_complete')
                waiter.wait(StackName=stack_name)

            def wait_for_stackset_creation(stackset_name, operation_id):
                cfn_client = boto3.client('cloudformation')
                response = cfn_client.describe_stack_set_operation(
                    StackSetName=stackset_name,
                    OperationId=operation_id
                )
                status = response['StackSetOperation']['Status']
                while status == 'RUNNING':
                    time.sleep(10)
                    response = cfn_client.describe_stack_set_operation(
                        StackSetName=stackset_name,
                        OperationId=operation_id
                    )
                    status = response['StackSetOperation']['Status']
                if status == 'SUCCEEDED':
                    logging.info('StackSet creation completed successfully.')
                else:
                    logging.info('StackSet creation failed.')

            def is_organization_account():
                try:
                    if os.getenv('IsOrg', 'error').lower() == 'false':
                        return False, None
                    org_client = boto3.client('organizations')
                    root_response = org_client.list_roots()
                    if 'Roots' in root_response and len(root_response['Roots']) > 0:
                        return True, root_response['Roots'][0]['Id']
                except Exception as e:
                    logging.info(f"Error checking organization status: {e}")
                return False, None

            def create_executionrole_on_childs(management_account_id, root_ou_id, regions, url):
                try:
                    cfn_client = boto3.client('cloudformation')
                    cfn_client.create_stack_set(
                        StackSetName='cyngular-execution-role-stackset',
                        Description='Cyngular Deployments | Child Accounts, Regional scope',
                        TemplateURL=url,
                        # TemplateBody=EXECUTION_ROLE_TEMPLATE,
                        AutoDeployment = {
                            'Enabled': True,
                            'RetainStacksOnAccountRemoval': False
                        },
                        PermissionModel = 'SERVICE_MANAGED',
                        Capabilities = ['CAPABILITY_IAM',"CAPABILITY_NAMED_IAM"],
                        Parameters = [
                            { 
                                'ParameterKey': 'AdministratorAccountId',
                                'ParameterValue': management_account_id
                            }
                        ]
                    )
                    result = cfn_client.create_stack_instances(
                            StackSetName = 'cyngular-execution-role-stackset',
                            DeploymentTargets = {
                                "OrganizationalUnitIds": [root_ou_id]
                            },
                            Regions = [regions[0]],
                            OperationPreferences = {
                                'RegionConcurrencyType': 'PARALLEL',
                                'FailureTolerancePercentage': 100,
                                'MaxConcurrentPercentage': 100,
                                'ConcurrencyMode': 'SOFT_FAILURE_TOLERANCE'
                            }
                        )
                    wait_for_stackset_creation("cyngular-execution-role-stackset", result["OperationId"])
                except Exception as e:
                    logging.info(f"Error creating execution-role on childs: {e}")

            def create_management_execution_role(management_account_id, url):
                cfn_client = boto3.client('cloudformation')
                if not check_role_existence("AWSCloudFormationStackSetExecutionRole"):
                    cfn_client.create_stack(
                        StackName='cyngular-managment-execution-role',
                        TemplateURL=url,
                        # TemplateBody=EXECUTION_ROLE_TEMPLATE,
                        Capabilities=['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM'],
                        Parameters = [
                            {
                                'ParameterKey': 'AdministratorAccountId',
                                'ParameterValue': management_account_id
                            }
                        ]
                    )
                    wait_for("cyngular-managment-execution-role")

            def create_management_admin_role(url):
                cfn_client = boto3.client('cloudformation')
                if not check_role_existence("AWSCloudFormationStackSetAdministrationRole"):
                    cfn_client.create_stack(
                        StackName='cyngular-managment-admin-role',
                        # TemplateBody=ADMIN_ROLE_TEMPLATE,
                        TemplateURL=url,
                        Capabilities=['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM']
                    )
                    wait_for("cyngular-managment-admin-role")

            def cyngular_function(event, context):
                try:
                    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                    logger = logging.getLogger()
                    logger.setLevel(logging.INFO)
                    logger.info('STARTING CYNGULAR\'S FUNCTION...')

                    if event['RequestType'] == 'Create':        
                        try:
                            exec_stack_url = event['ResourceProperties']['EXEC_TEMPLATE_URL']
                            admin_stack_url = event['ResourceProperties']['ADMIN_TEMPLATE_URL']

                            mgmt_acc_id = boto3.client('sts').get_caller_identity()['Account']
                            is_org, root_ou_id = is_organization_account()
                            regions = list(set(os.getenv('CLIENT_REGIONS', '').split(',')))

                            logger.info("CREATING ROLES ON MANAGEMENT ACCOUNT")
                            create_management_execution_role(mgmt_acc_id, exec_stack_url)
                            create_management_admin_role(admin_stack_url)

                            if is_org:
                                # check_role_existence_in_child(mgmt_acc_id) ## check for all accounts
                                logger.info("CREATING ROLES ON CHILDS")
                                create_executionrole_on_childs(mgmt_acc_id, root_ou_id, regions, exec_stack_url)
                            logger.info("DONE WITH ALL CYNGULAR STACKS!")

                            cfnresponse.send(event, context, cfnresponse.SUCCESS, {'msg' : '-- Done --'})

                        except Exception as e:
                            logger.critical(str(e))
                            cfnresponse.send(event, context, cfnresponse.FAILED, {'msg' : str(e)})
                    else:
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {'msg' : f"RequestType of event is not \'Create\', it is {event['RequestType']}"})
                except Exception as e:
                    logger.critical(str(e))
                    cfnresponse.send(event, context, cfnresponse.FAILED, {'msg' : str(e)})
      Tags:
        - Key: Name
          Value: "cyngular-lambda-admin-and-execution-roles"
        - Key: Vendor
          Value: "Cyngular Security"

  StackSetManagerTrigger:
    DependsOn: [AdminAndExecTrigger]
    Type: Custom::StackSetManager
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Version: "1.0"
    Properties:
      ServiceToken: !GetAtt LambdaStackSetManager.Arn
      ServiceTimeout: 1200
      Stack2URL: !Sub
        - "https://${bucket_name}.s3.amazonaws.com/stacks/stack2.yaml"
        - bucket_name: !FindInMap [VARS, Cyngular, TemplateBucket]

      StackSet1URL: !Sub
        - "https://${bucket_name}.s3.amazonaws.com/stacks/stackset_child1.yaml"
        - bucket_name: !FindInMap [VARS, Cyngular, TemplateBucket]

      StackSet2URL: !Sub
        - "https://${bucket_name}.s3.amazonaws.com/stacks/stackset_child2.yaml"
        - bucket_name: !FindInMap [VARS, Cyngular, TemplateBucket]

  LambdaStackSetManager:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "cyngular-lambda-stackset-manager"
      Description: Created by Cyngular Security.
      Role: !GetAtt ManagerLambdaRole.Arn

      Runtime: python3.12
      Handler: index.cyngular_function
      Timeout: 900
      Environment:
        Variables:
          ClientName: !Ref ClientName
          ClientRegions: !Join [",", !Ref ClientRegions]

          UpdateBucketPolicyLambdaName: !Ref LambdaUpdateCyngularBucketPolicy

          CyngularAccountId: !Ref CyngularAccountId
          S3BucketArn: !GetAtt CyngularS3Bucket.Arn
          IsOrg: !If [IsOrg, true, false]

          EnableDNS: !Ref EnableDNS
          EnableEKS: !Ref EnableEKS
          EnableVPCFlowLogs: !Ref EnableVPCFlowLogs
      Code:
        ZipFile: |
            import boto3
            import time
            import os
            import cfnresponse
            import logging

            def is_organization_account():
                try:
                    if os.getenv('IsOrg', 'error').lower() == 'false':
                        return False, None
                    org_client = boto3.client('organizations')
                    root_response = org_client.list_roots()
                    if 'Roots' in root_response and len(root_response['Roots']) > 0:
                        return True, root_response['Roots'][0]['Id']
                except Exception as e:
                    logging.info(f"Error checking organization status: {e}")
                return False, None

            def create_stack2(mgmt_acc_id, regions, url):
                cfn_client = boto3.client('cloudformation')
                cfn_client.create_stack_set(
                    StackSetName = 'cyngular-stackset-mgmt-regional',
                    Description = 'Cyngular Deployments | MGMT Account, Regional scope',
                    TemplateURL = url,
                    PermissionModel = 'SELF_MANAGED',
                    Capabilities = ['CAPABILITY_IAM','CAPABILITY_NAMED_IAM'],
                    Parameters = [
                        {
                            'ParameterKey': 'CyngularAccountId',
                            'ParameterValue': os.environ['CyngularAccountId']
                        },
                        {
                            'ParameterKey': 'S3BucketArn',
                            'ParameterValue': os.environ['S3BucketArn']
                        },
                        {
                            'ParameterKey': 'EnableDNS',
                            'ParameterValue': os.environ['EnableDNS']
                        }
                    ],
                    Tags = [
                        {
                            'Key': 'Company',
                            'Value': os.environ['ClientName']
                        },
                        {
                            'Key': 'Vendor',
                            'Value': 'Cyngular Security'
                        }
                    ]
                )
                cfn_client.create_stack_instances(
                    StackSetName = 'cyngular-stackset-mgmt-regional',
                    DeploymentTargets = {
                        "Accounts": [mgmt_acc_id]
                    },
                    Regions = regions,
                    OperationPreferences = {
                        'RegionConcurrencyType': 'PARALLEL',
                        'FailureTolerancePercentage': 100,
                        'MaxConcurrentPercentage': 100,
                        'ConcurrencyMode': 'SOFT_FAILURE_TOLERANCE'
                    }
                )
            def create_stackset1(deployment_targets, regions, url):
                cfn_client = boto3.client('cloudformation')
                cfn_client.create_stack_set(
                    StackSetName = 'cyngular-stackset-1',
                    Description = 'Cyngular Deployments | Child Accounts, Global scope',
                    TemplateURL = url,
                    PermissionModel = 'SERVICE_MANAGED',
                    AutoDeployment = {
                        'Enabled': True,
                        'RetainStacksOnAccountRemoval': False
                    },
                    ManagedExecution = {
                      'Active': True
                    },
                    Capabilities = ['CAPABILITY_IAM','CAPABILITY_NAMED_IAM'],
                    Parameters = [
                        {
                            'ParameterKey': 'ClientName',
                            'ParameterValue': os.environ['ClientName']
                        },
                        {
                            'ParameterKey': 'CyngularAccountId',
                            'ParameterValue': os.environ['CyngularAccountId']
                        },
                        {
                            'ParameterKey': 'S3BucketArn',
                            'ParameterValue': os.environ['S3BucketArn']
                        },
                        {
                            'ParameterKey': 'ClientRegions',
                            'ParameterValue': ','.join(regions)
                        },
                        {
                            'ParameterKey': 'EnableDNS',
                            'ParameterValue': (os.environ['EnableDNS'])
                        },
                        {
                            'ParameterKey': 'EnableEKS',
                            'ParameterValue': (os.environ['EnableEKS'])
                        },
                        {
                            'ParameterKey': 'EnableVPCFlowLogs',
                            'ParameterValue': (os.environ['EnableVPCFlowLogs'])
                        }
                    ],
                    Tags = [
                        {
                            'Key': 'Company',
                            'Value': os.environ['ClientName']
                        },
                        {
                            'Key': 'Vendor',
                            'Value': 'Cyngular Security'
                        }
                    ]
                )
                cfn_client.create_stack_instances(
                    StackSetName = 'cyngular-stackset-1',
                    DeploymentTargets = deployment_targets,
                    Regions = [regions[0]],
                    OperationPreferences = {
                        'RegionConcurrencyType': 'PARALLEL',
                        'FailureTolerancePercentage': 100,
                        'MaxConcurrentPercentage': 100,
                        'ConcurrencyMode': 'SOFT_FAILURE_TOLERANCE'
                    }
                )
            def create_stackset2(deployment_targets, regions, url):
                cfn_client = boto3.client('cloudformation')
                cfn_client.create_stack_set(
                    StackSetName = 'cyngular-stackset-2',
                    Description = 'Cyngular Deployments | Child Accounts, Regional scope',
                    TemplateURL = url,
                    PermissionModel = 'SERVICE_MANAGED',
                    AutoDeployment = {
                        'Enabled': True,
                        'RetainStacksOnAccountRemoval': False
                    },
                    Capabilities = ['CAPABILITY_IAM','CAPABILITY_NAMED_IAM'],
                    Parameters = [
                        {
                            'ParameterKey': 'CyngularAccountId',
                            'ParameterValue': os.environ['CyngularAccountId']
                        },
                        {
                            'ParameterKey': 'S3BucketArn',
                            'ParameterValue': os.environ['S3BucketArn']
                        },
                        {
                            'ParameterKey': 'EnableDNS',
                            'ParameterValue': os.environ['EnableDNS']
                        }
                    ]
                )
                cfn_client.create_stack_instances(
                    StackSetName = 'cyngular-stackset-2',
                    DeploymentTargets = deployment_targets,
                    Regions = regions,
                    OperationPreferences = {
                        'RegionConcurrencyType': 'PARALLEL',
                        'FailureTolerancePercentage': 100,
                        'MaxConcurrentPercentage': 100,
                        'ConcurrencyMode': 'SOFT_FAILURE_TOLERANCE'
                    }
                )
            def invoke_lambda(func_name):
                try:
                    lambda_client = boto3.client('lambda')
                    response = lambda_client.invoke(
                        FunctionName = func_name,
                        InvocationType = 'RequestResponse',
                        LogType = 'Tail'
                    )
                    logging.info('lmbada E invoked!')
                    if response['StatusCode'] != 200:
                        logging.critical(f"Error {response}")
                except Exception as e:
                    logging.critical(str(e))
            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STARTING CYNGULAR\'S FUNCTION...')
                try:
                    if event['RequestType'] == 'Create':
                        try:                            
                            mgmt_acc_id = boto3.client('sts').get_caller_identity()['Account']

                            is_org, root_id = is_organization_account()
                            deployment_targets = {'OrganizationalUnitIds': [root_id]} if is_org else {'Accounts': [mgmt_acc_id]}
                            regions = list(set(os.getenv('ClientRegions', '').split(',')))
                            logger.info(f"deploy targets -> {deployment_targets}")

                            stack2_url = event['ResourceProperties']['Stack2URL']
                            stackset1_url = event['ResourceProperties']['StackSet1URL']
                            stackset2_url = event['ResourceProperties']['StackSet2URL']
                            lambda_E_name = os.environ['UpdateBucketPolicyLambdaName']

                            logger.info("Updating Bucket Policy")
                            invoke_lambda(lambda_E_name)
                            time.sleep(60)
                            logger.info("STARING CYNGULAR STACK2")
                            create_stack2(mgmt_acc_id, regions, stack2_url)

                            if is_org:
                                logger.info("STARING CYNGULAR STACKSET1")
                                create_stackset1(deployment_targets, regions, stackset1_url)

                                logger.info("STARING CYNGULAR STACKSET2")
                                create_stackset2(deployment_targets, regions, stackset2_url)
                            logger.info("DONE WITH ALL CYNGULAR STACKS!")
                            cfnresponse.send(event, context, cfnresponse.SUCCESS, {'msg' : 'Done'})

                        except Exception as e:
                            logger.critical(str(e))
                            cfnresponse.send(event, context, cfnresponse.FAILED, {'msg' : str(e)})
                    else:
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {'msg' : 'No error'})
                except Exception as e:
                    logger.critical(str(e))
                    cfnresponse.send(event, context, cfnresponse.FAILED, {'msg' : str(e)})
      Tags:
        - Key: Name
          Value: "cyngular-lambda-stackset-manager"
        - Key: Vendor
          Value: "Cyngular Security"