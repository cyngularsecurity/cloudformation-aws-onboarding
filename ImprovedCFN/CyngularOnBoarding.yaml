AWSTemplateFormatVersion: 2010-09-09
Description: >-
  Cyngular: v3.3 -
  Main OnBoarding stack template

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Client Info
        Parameters:
          - ClientName
          - ClientRegions
          - OrganizationId
      - Label:
          default: Services
        Parameters:
          - CloudTrailBucket
          - EnableDNS
          - EnableVPCFlowLogs
          - EnableEKS
      - Label:
          default: Cyngular Info
        Parameters:
          - CyngularAccountId

    ParameterLabels:
      ClientName:
        default: "Company Name"
      ClientRegions:
        default: "Company Regions"
      OrganizationId:
        default: "Organization Id"
      CloudTrailBucket:
        default: "CloudTrail Bucket Name"
      EnableDNS:
        default: "DNS Enabled"
      EnableEKS:
        default: "EKS Enabled"
      EnableVPCFlowLogs:
        default: "VPCFlowLogs Enabled"
      CyngularAccountId:
        default: "Cyngular Account Id"

Parameters:
  ClientName:
    Description: "The name of the client. (must be lowercase, can contain letters, numbers and dashes)"
    Type: "String"
    AllowedPattern: "^[a-z0-9]+$"
    MinLength: 3
    MaxLength: 10

  OrganizationId:
    Description: "Specify the company Organization id | leave empty if not using Organization feature"
    Type: String
    Default: ""

  ClientRegions:
    Description: "The regions in which your company operates in (comma-separated for example; us-east-1,us-east-2), make sure all regions specified are enabled in the relevent accounts"
    Type: CommaDelimitedList
    AllowedValues: [me-south-1, us-east-1, us-east-2, us-west-1, us-west-2, ap-southeast-1, ap-southeast-2, ap-south-1, ap-northeast-1, ap-northeast-2, ap-northeast-3, af-south-1, eu-west-1, eu-west-2, eu-west-3, eu-central-1, eu-central-2, eu-north-1, eu-south-1, eu-south-2, ca-central-1, sa-east-1, il-central-1, af-north-1, ap-east-1, ap-south-2, ap-southeast-3, ap-southeast-4, ap-southeast-5, ca-west-1, me-central-1]

  CloudTrailBucket:
    Description: "Enter a bucket Name, if you already configured CloudTrail To Send Logs to an S3 bucket. if so, also add the tag {key: 'cyngular-cloudtrail', value: 'true'} to the bucket, otherwise leave empty."
    Type: String
    Default: ""

  EnableDNS:
    Description: "Set to 'true' to enable the service if not already enabled; set to 'false' if the service is enabled or not desired. Add the tag {key: 'cyngular-dnslogs', value: 'true'} to the resource bucket only if telemetry is already collected for Cyngular analysis."
    Type: String
    AllowedValues: ["true", "false"]
    Default: "true"

  EnableEKS:
    Description: "EKS Service - Whether to Configure EKS Audit & Authenticator Logging for kubernetes Clusters."
    Type: String
    AllowedValues: ["true", "false"]
    Default: "true"

  EnableVPCFlowLogs:
    Description: "Set to 'true' to enable the service if not already enabled; set to 'false' if the service is enabled or not desired. Add the tag {key: 'cyngular-vpcflowlogs', value: 'true'} to the resource bucket only if telemetry is already collected for Cyngular analysis."
    Type: String
    AllowedValues: ["true", "false"]
    Default: "true"

  CyngularAccountId:
    Description: "The cyngular Account ID to assume the read only role [851565895544]"
    Type: String
    Default: "851565895544"

Conditions:
  IsOrg: !Not [!Equals [!Ref OrganizationId, ""]]
  CreateCloudTrail: !Equals [ !Ref CloudTrailBucket, "" ]

  ServiceDNS: !Equals [ !Ref EnableDNS, "true" ]
  ServiceEKS: !Equals [ !Ref EnableEKS, "true" ]
  ServiceVFL: !Equals [ !Ref EnableVPCFlowLogs, "true" ]

Resources:
  CyngularS3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      BucketName: !Sub "cyngular-${ClientName}-bucket-${AWS::AccountId}"

      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub "cyngular-${ClientName}-bucket-${AWS::AccountId}"

        - Key: cyngular-os
          Value: true
        - Key: cyngular-visibility
          Value: true
        - !If
            - CreateCloudTrail
            - Key: cyngular-cloudtrail
              Value: true
            - !Ref AWS::NoValue
        - !If
            - ServiceDNS
            - Key: cyngular-dnslogs
              Value: true
            - !Ref AWS::NoValue
        - !If
            - ServiceVFL
            - Key: cyngular-vpcflowlogs
              Value: true
            - !Ref AWS::NoValue
        - !If
            - ServiceEKS
            - Key: cyngular-ekslogs
              Value: true
            - !Ref AWS::NoValue

  S3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref CyngularS3Bucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: 'LambdaRead'
            Effect: Allow
            Principal: 
              AWS: [
                !Sub "arn:aws:iam::${AWS::AccountId}:root",
                !Sub "arn:aws:iam::${CyngularAccountId}:root"                
              ]
            Action:
              - 's3:*'
            Resource:
              - !GetAtt CyngularS3Bucket.Arn
              - !Sub "arn:aws:s3:::${CyngularS3Bucket}/*"

          - !If
            - CreateCloudTrail
            - Sid: 'CloudTrailAclCheck'
              Effect: Allow
              Principal:
                Service: "cloudtrail.amazonaws.com"
              Action: 's3:GetBucketAcl'
              Resource: !GetAtt CyngularS3Bucket.Arn
              Condition:
                StringEquals:
                  AWS:SourceArn: !Sub "arn:aws:cloudtrail:${AWS::Region}:${AWS::AccountId}:trail/cyngular-cloudtrail"
            - !Ref "AWS::NoValue"

          - !If 
            - CreateCloudTrail
            - Sid: 'CloudTrailWrite'
              Effect: Allow
              Principal: 
                Service: "cloudtrail.amazonaws.com"
              Action: 
                - 's3:PutObject'
              Resource: 
                - !Sub "arn:aws:s3:::${CyngularS3Bucket}/AWSLogs/${AWS::AccountId}/*"
                - !If 
                  - IsOrg
                  - !Sub "arn:aws:s3:::${CyngularS3Bucket}/AWSLogs/${OrganizationId}/*"
                  - !Ref "AWS::NoValue"
              Condition:
                StringEquals:
                  s3:x-amz-acl: "bucket-owner-full-control"
                  AWS:SourceArn: !Sub "arn:aws:cloudtrail:${AWS::Region}:${AWS::AccountId}:trail/cyngular-cloudtrail"
            - !Ref "AWS::NoValue"

  ClientCloudTrail:
    DependsOn: S3BucketPolicy
    Condition: CreateCloudTrail
    Type: AWS::CloudTrail::Trail
    Properties:
      TrailName: cyngular-cloudtrail
      S3BucketName: !Ref CyngularS3Bucket
      InsightSelectors:
        - InsightType: ApiCallRateInsight
        - InsightType: ApiErrorRateInsight
      EventSelectors:
        - IncludeManagementEvents: true
          ExcludeManagementEventSources:
            - kms.amazonaws.com
          DataResources:
            - Type: AWS::Lambda::Function
              Values:
                - arn:aws:lambda
      IsLogging: true
      IsMultiRegionTrail: true
      IsOrganizationTrail: !If [IsOrg, true, false]
      IncludeGlobalServiceEvents: true
      Tags:
        - Key: Name
          Value: cyngular-cloudtrail

  ClientCyngularRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "cyngular-readonly-role-${ClientName}"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${CyngularAccountId}:root"
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: cyngular-readonly-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: readOnly
                Effect: Allow
                Resource: '*'
                Action:
                  - iam:List*
                  - iam:Get*
                  - iam:GenerateServiceLastAccessedDetails

                  - organizations:Describe*
                  - organizations:List*

                  - ce:GetCostAndUsage
                  - ce:GetDimensionValues

                  - s3:List*
                  - s3:Describe*
                  - s3:GetBucketAcl
                  - s3:GetBucketLocation
                  - s3:GetBucketPolicyStatus
                  - s3:GetEncryptionConfiguration
                  - s3:GetAccountPublicAccessBlock
                  - s3:GetBucketPublicAccessBlock

                  - logs:List*
                  - logs:Describe*
                  - logs:Get*
                  - logs:FilterLogEvents
                  - logs:StartQuery
                  - cloudwatch:GetMetricStatistics

                  - ec2:List*
                  - ec2:CreateTags
                  - ec2:Describe*
                  - ec2:GetImageBlockPublicAccessState
                  - ecr:Describe*
                  - ecr:List*
                  - eks:Describe*
                  - eks:List*
                  - ecs:List*
                  - ecs:Describe*
                  - lambda:List*
                  - lambda:Get*
                  - rds:List*
                  - rds:Describe*

                  - cloudformation:Describe*
                  - cloudformation:List*
                  - cloudformation:Get*
                  
                  - tag:GetResources

                  - route53:Get*
                  - route53:List*
                  - route53:TestDNSAnswer

                  - cloudtrail:GetTrail
                  - cloudtrail:DescribeTrails
                  - cloudtrail:GetTrailStatus
                  - cloudtrail:LookupEvents
                  - cloudtrail:ListTags
                  - cloudtrail:ListTrails
                  - cloudtrail:GetEventSelectors
                  - cloudtrail:GetInsightSelectors

                  - kms:Describe*
                  - kms:Get*
                  - kms:List*

                  - events:ListRules
                  - events:ListTargetsByRule
                  - events:ListEventBuses
                  - events:DescribeEventBus
                  - events:DescribeRule
                  - events:TestEventPattern

                  - cloudwatch:ListMetrics
                  - cloudwatch:GetMetricData

              - Sid: ec2CyngularSnapshot
                Effect: Allow
                Action:
                  - ec2:DeleteSnapshot
                  - ec2:ModifySnapshotAttribute
                Resource: '*'
                Condition:
                  StringLike:
                    aws:ResourceTag/Name: cyngular*

              - Sid: ec2CreateSnapshot
                Effect: Allow
                Resource: '*'
                Action:
                  - ec2:CopySnapshot
                  - ec2:CreateSnapshot
                  - ec2:CreateSnapshots

              - Sid: CyngularBucketAdmin
                Effect: Allow
                Resource:
                  - !GetAtt CyngularS3Bucket.Arn
                  - !Sub ["${bucket_arn}/*", bucket_arn: !GetAtt CyngularS3Bucket.Arn]
                Action:
                  - "s3:*"

              - Sid: KmsPartial
                Effect: Allow
                Resource: '*'
                Action:
                  - kms:Decrypt
                  - kms:CreateGrant

              - Sid: CyngularKmsKey
                Effect: Allow
                Resource: '*'
                Action:
                  - kms:*
                Condition:
                  StringLike:
                    aws:ResourceTag/Name: cyngular*

              - Sid: "ListRegionsOnAccounts"
                Effect: "Allow"
                Action:
                  - "account:ListRegions"
                Resource:
                  - arn:aws:account::*:account/o-*/*
                  - arn:aws:account::*:account

  LambdasRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "cyngular-lambdas-role-${ClientName}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service: 
                - "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: cyngular-lambdas-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: first
                Effect: Allow
                Resource: '*'
                Action:
                  - logs:*
                  - route53resolver:*

                  - sts:GetCallerIdentity
                  - organizations:ListAccounts

                  - eks:List*
                  - eks:UpdateClusterConfig

                  - ec2:Describe*
                  - ec2:CreateFlowLogs
                  - ec2:DeleteFlowLogs
                  - ec2:CreateTags
                  - ec2:DeleteTags

                  - events:PutRule
                  - events:DisableRule

                  - lambda:UpdateFunctionConfiguration
                  - lambda:InvokeFunction

              - Sid: CyngularBucketAdmin
                Effect: Allow
                Resource:
                  - !GetAtt CyngularS3Bucket.Arn
                  - !Sub ["${bucket_arn}/*", bucket_arn: !GetAtt CyngularS3Bucket.Arn]
                Action:
                  - "s3:*"

              - Sid: EditEKS
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:eks:*:${AWS::AccountId}:cluster/*"
                  - !Sub "arn:aws:eks:*:${AWS::AccountId}:access-entry/*/role/${AWS::AccountId}/cyngular-readonly-role-${ClientName}/*"
                Action:
                  - "eks:CreateAccessEntry"
                  - "eks:AssociateAccessPolicy"
                  - "eks:DescribeCluster"

  LambdaEKS:
    Type: AWS::Lambda::Function
    Condition: ServiceEKS
    Properties:
      FunctionName: "cyngular-lambda-config-eks"
      Description: "Created by Cyngular Security | Configure EKS Logging"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Join [" ", !Ref ClientRegions]
          FINAL_CRON: "cron(0 * * * ? *)"
          FIRST_RUN: "true"
          ROLE_ARN: !GetAtt ClientCyngularRole.Arn

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 300
      Code:
        ZipFile: |
            import boto3
            import traceback
            import os
            import logging
            from botocore.exceptions import ClientError

            def check_access_entry_exists(eks_client, cluster_name, role_arn):
                try:
                    response = eks_client.list_access_entries(clusterName=cluster_name)
                    if 'accessEntries' in response:
                        return role_arn in response['accessEntries']
                    return False
                except eks_client.exceptions.ResourceNotFoundException:
                    logging.error(f'Cluster {cluster_name} not found')
                    return False
                except ClientError as e:
                    if e.response['Error']['Code'] == 'InvalidRequestException' and 'authentication mode' in str(e):
                        logging.warning(f'Cluster {cluster_name} has incompatible authentication mode for access entries')
                        return False
                except Exception as e:
                    logging.error(f'Error checking access entries: {str(e)}')
                    return False

            def create_access_entry(eks_client, logger, cluster_name, role_arn):
                try:
                    try:
                        cluster_info = eks_client.describe_cluster(name=cluster_name)
                        auth_mode = cluster_info['cluster'].get('accessConfig', {}).get('authenticationMode', 'CONFIG_MAP')
                        if auth_mode not in ['API', 'API_AND_CONFIG_MAP']:
                            logger.warning(f'Skipping access entry creation for cluster {cluster_name} - incompatible authentication mode: {auth_mode}')
                            return
                    except Exception as e:
                        logger.error(f'Error checking cluster authentication mode: {str(e)}')
                        return

                    if check_access_entry_exists(eks_client, cluster_name, role_arn):
                        logger.info(f'Access entry for role {role_arn} already exists in cluster {cluster_name}.')
                        return

                    logger.info(f'Creating access entry for cluster: {cluster_name}')
                    response = eks_client.create_access_entry(
                        clusterName=cluster_name,
                        principalArn=role_arn,
                        type='STANDARD'
                    )
                    logger.info(f'Access entry created successfully: {response["accessEntry"]["accessEntryArn"]}')

                    logger.info(f'Associating access policy for cluster: {cluster_name}')
                    eks_client.associate_access_policy(
                        clusterName=cluster_name,
                        principalArn=role_arn,
                        policyArn='arn:aws:eks::aws:cluster-access-policy/AmazonEKSViewPolicy',
                        accessScope={
                            'type': 'cluster'
                        }
                    )
                    logger.info('Access policy associated successfully')
                except eks_client.exceptions.ResourceNotFoundException as e_not_found:
                    logger.error(f'Cluster {cluster_name} not found -- {str(e_not_found)}')
                except eks_client.exceptions.AccessDeniedException as e_access_denied:
                    logger.error(f'Access denied when creating access entry for cluster {cluster_name} -- {str(e_access_denied)}')
                except Exception as e:
                    logger.error(f'Error creating access entry: {str(e)}')

            def ekslogs(curr_region, logger, role_arn):
                try:
                    logger.info('STARTING EKSLOGS...')
                    wanted_cluster_logging_config = {
                        'clusterLogging': [{
                            'types': ['audit', 'authenticator'],
                            'enabled': True
                        }]
                    }
                    eks_client = boto3.client('eks', region_name=curr_region)
                    logger.info('EKS client created successfully')
                    
                    clusters = eks_client.list_clusters()['clusters']
                    logger.info(f'Found {len(clusters)} clusters in region {curr_region}')

                    for cluster_name in clusters:
                        try:
                            logger.info(f'CONFIGURING EKSLOGS ON CLUSTER: {cluster_name}')
                            eks_client.update_cluster_config(
                                name=cluster_name,
                                logging=wanted_cluster_logging_config
                            )
                            logger.info(f'COMMAND SUCCEEDED.')
                            
                        except Exception as e:
                            if 'No changes needed for the logging config provided' not in str(e):
                                logger.critical(f'COMMAND FAILED - {str(e)}')
                            else:
                                logger.info(f'No changes needed for cluster {cluster_name}')
                
                        create_access_entry(eks_client, logger, cluster_name, role_arn)

                except Exception as e:
                    logger.critical(f'Error in ekslogs function: {str(e)}')
                    logger.critical(traceback.format_exc())
                    
            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STARTING CYNGULARS FUNCTION...')

                LAMBDA_NAME = context.function_name
                REGIONS = os.environ['CLIENT_REGIONS']
                ROLE_ARN = os.environ['ROLE_ARN']
                try:
                    if os.environ.get('FIRST_RUN') == 'true':
                        logger.info('First run detected. Updating EventBridge rule schedule.')
                        try:
                            lambda_client = boto3.client('lambda')
                            events_client = boto3.client('events')
                            response = events_client.put_rule(
                                Name=f"{LAMBDA_NAME}-rule",
                                State='ENABLED',
                                ScheduleExpression=os.environ['FINAL_CRON'],
                                Description='LambdaEKS | Scheduled to run hourly',
                                EventBusName='default'
                            )
                            logger.info('Successfully updated the EventBridge rule: %s', response)
                            response = lambda_client.update_function_configuration(
                                FunctionName=LAMBDA_NAME,
                                Environment={'Variables': {"FIRST_RUN": "false", "CLIENT_REGIONS": REGIONS, "ROLE_ARN": ROLE_ARN}}
                            )
                            logger.info('Successfully updated the function configuration: %s', response)
                        except Exception as e:
                            logger.critical('Error updating the EventBridge rule: %s', str(e))
                            raise

                    logger.info('STARTING EKSLOGS...')                    
                    for curr_region in REGIONS.split(' '):
                        logger.info(f'AWS REGION: {curr_region}')
                        try:
                            ekslogs(curr_region, logger, ROLE_ARN)
                        except Exception as e:
                            logger.critical(str(e))
                    logger.info('DONE!')
                    return {
                        'statusCode': 200,
                        'body': 'Function executed successfully'
                    }

                except Exception as e:
                    logger.critical(str(e))
                    return {
                        'statusCode': 500,
                        'body': f'Error occurred: {str(e)}'
                    }

  ScheduledRuleLambdaEKS:
    Type: AWS::Events::Rule
    DependsOn: [StackSetManagerTrigger]
    Condition: ServiceEKS
    Properties:
      Name: !Sub "${LambdaEKS}-rule"
      Description: "Function did not run yet"
      ScheduleExpression: "rate(2 minutes)"
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaEKS.Arn
          Id: "TargetFunctionV1"

  PermissionForEventsToInvokeLambdaEKS: 
    Type: AWS::Lambda::Permission
    Condition: ServiceEKS
    Properties: 
      FunctionName: !Ref LambdaEKS
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt ScheduledRuleLambdaEKS.Arn

  LambdaDNS:
    Type: AWS::Lambda::Function
    Condition: ServiceDNS
    Properties:
      FunctionName: "cyngular-lambda-config-dns"
      Description: "Created by Cyngular Security. | Configure DNS"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Join [" ", !Ref ClientRegions]
          FINAL_CRON: "cron(0 * * * ? *)"
          FIRST_RUN: "true"

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 300
      Code:
        ZipFile: |
            import boto3
            import traceback
            import os
            import logging

            def dnslogs(curr_region):
                try:
                    logging.info(f'STARTING DNSLOGS...')
                    r_53_client = boto3.client('route53resolver', region_name=curr_region)
                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    
                    region_query_log_configs = r_53_client.list_resolver_query_log_configs()['ResolverQueryLogConfigs']
                    cyngular_resolver_id = ''
                    
                    for region_query_log_config in region_query_log_configs:
                        try:
                            if region_query_log_config['Name'] == 'cyngular_dns':
                                cyngular_resolver_id = region_query_log_config['Id']
                                break
                        except:
                            pass

                    if cyngular_resolver_id:
                        vpc_list = ec2_client.describe_vpcs()
                        if "Vpcs" in vpc_list:                  
                            for vpc in vpc_list["Vpcs"]:
                                try:
                                    vpc_id = vpc["VpcId"]
                                    logging.info(f'CONFIGURING DNSLOGS ON VPC-ID: {vpc_id}')
                                    resp = r_53_client.associate_resolver_query_log_config(ResolverQueryLogConfigId = cyngular_resolver_id, ResourceId = vpc_id )
                                    logging.info(f'COMMAND SUCCEEDED.')
                                except Exception as e:
                                    if not 'already associated' in str(e):
                                        logging.critical(str(e))
                except Exception as e:
                    logging.critical(str(e))

            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STRATING CYNGULARS FUNCTION...')

                LAMBDA_NAME=context.function_name
                REGIONS=os.environ['CLIENT_REGIONS']
                try:
                    if os.environ.get('FIRST_RUN') == 'true':
                        logger.info('First run detected. Updating EventBridge rule schedule.')
                        try:
                            lambda_client = boto3.client('lambda')
                            events_client = boto3.client('events')
                            response = events_client.put_rule(
                                Name = f"{LAMBDA_NAME}-rule",
                                State = 'ENABLED',
                                ScheduleExpression = os.environ['FINAL_CRON'],
                                Description = 'LambdaDNS | Scheduled to run hourly',
                                EventBusName = 'default'
                            )
                            logger.info('Successfully updated the EventBridge rule: %s', response)
                            response = lambda_client.update_function_configuration(
                                FunctionName=LAMBDA_NAME,
                                Environment={'Variables': {"FIRST_RUN": "false", "CLIENT_REGIONS": REGIONS}}
                            )
                            logger.info('Successfully updated the function configuration: %s', response)
                        except Exception as e:
                            logger.critical('Error updating the EventBridge rule: %s', str(e))
                            raise

                    logger.info('STARTING DNSLOGS...')                    
                    for curr_region in REGIONS.split(' '):
                        logging.info(f'AWS REGION: {curr_region}')
                        try:
                            dnslogs(curr_region)
                        except Exception as e:
                            logging.critical(str(e))
                    logging.info('DONE!')

                except Exception as e:
                    logging.critical(str(e))

  ScheduledRuleLambdaDNS: 
    Type: AWS::Events::Rule
    DependsOn: [StackSetManagerTrigger]
    Condition: ServiceDNS
    Properties:
      Name: !Sub "${LambdaDNS}-rule"
      Description: "Function did not run yet"
      ScheduleExpression: "rate(2 minutes)"
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaDNS.Arn
          Id: "TargetFunctionV1"

  PermissionForEventsToInvokeLambdaDNS: 
    Type: AWS::Lambda::Permission
    Condition: ServiceDNS
    Properties: 
      FunctionName: !Ref LambdaDNS
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt ScheduledRuleLambdaDNS.Arn

  LambdaVFL:
    Type: AWS::Lambda::Function
    Condition: ServiceVFL
    Properties:
      FunctionName: "cyngular-lambda-config-vpcflowlogs"
      Description: "Created by Cyngular Security. | Configure VFL"
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          CLIENT_REGIONS: !Join [" ", !Ref ClientRegions]
          FINAL_CRON: "cron(0 * * * ? *)"
          FIRST_RUN: "true"
          CYNGULAR_BUCKET: !Ref CyngularS3Bucket

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 300
      Code:
        ZipFile: | 
            import boto3
            import traceback
            import os
            import logging

            def vpcflowlogs(curr_region, bucket_name):
                try:
                    logging.info('STARTING VPCFLOWLOGS...')

                    ec2_client = boto3.client('ec2', region_name=curr_region)
                    vpc_list = ec2_client.describe_vpcs()

                    vpc_id_list = []
                    if "Vpcs" in vpc_list:                  
                        for vpc in vpc_list["Vpcs"]:
                            vpc_id_list.append(vpc["VpcId"])

                    logging.info(f'CONFIGURING VPCFLOWLOGS ON VPC-IDS: {vpc_id_list}')
                    response = ec2_client.create_flow_logs(
                        ResourceIds=vpc_id_list,
                        ResourceType='VPC',
                        TrafficType='ALL',
                        LogDestinationType = 's3',
                        LogDestination = f"arn:aws:s3:::{bucket_name}",
                        TagSpecifications=[
                            {
                                'ResourceType': 'vpc-flow-log',
                                'Tags': [
                                    {
                                        'Key': 'Name',
                                        'Value': 'Cyngular-vpc-flowlogs'
                                    },
                                ]
                            },
                        ]
                    )
                    logging.info(f'COMMAND SUCCEEDED.')

                except Exception as e:
                    if 'FlowLogAlreadyExists' in str(e):
                        pass
                    else:
                        logging.critical(str(e))

            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STRATING CYNGULARS FUNCTION...')

                LAMBDA_NAME = context.function_name
                REGIONS = os.environ['CLIENT_REGIONS']
                bucket_name = os.environ['CYNGULAR_BUCKET']
                try:
                    if os.environ.get('FIRST_RUN') == 'true':
                        logger.info('First run detected. Updating EventBridge rule schedule.')
                        try:
                            lambda_client = boto3.client('lambda')
                            events_client = boto3.client('events')
                            response = events_client.put_rule(
                                Name = f"{LAMBDA_NAME}-rule",
                                State = 'ENABLED',
                                ScheduleExpression = os.environ['FINAL_CRON'],
                                Description = 'LambdaVFL | Scheduled to run hourly',
                                EventBusName = 'default'
                            )
                            logger.info('Successfully updated the EventBridge rule: %s', response)
                            response = lambda_client.update_function_configuration(
                                FunctionName=LAMBDA_NAME,
                                Environment={'Variables': {"FIRST_RUN": "false", "CLIENT_REGIONS": REGIONS, "CYNGULAR_BUCKET": bucket_name}}
                            )
                            logger.info('Successfully updated the function configuration: %s', response)
                        except Exception as e:
                            logger.critical('Error updating the EventBridge rule: %s', str(e))
                            raise

                    logger.info('STARTING VPCFLOWLOGS...')
                    for curr_region in REGIONS.split(' '):
                        logging.info(f'AWS REGION: {curr_region}')
                        try:
                            vpcflowlogs(curr_region, bucket_name)
                        except Exception as e:
                            logging.critical(str(e))
                    logging.info('DONE!')

                except Exception as e:
                    logging.critical(str(e))
  
  ScheduledRuleLambdaVFL:
    Type: AWS::Events::Rule
    DependsOn: [StackSetManagerTrigger]
    Condition: ServiceVFL
    Properties: 
      Name: !Sub "${LambdaVFL}-rule"
      Description: "Function did not run yet"
      ScheduleExpression: "rate(2 minutes)"
      State: "ENABLED"
      Targets: 
        - Arn: !GetAtt LambdaVFL.Arn
          Id: "TargetFunctionV1"

  PermissionForEventsToInvokeLambdaVFL: 
    Type: AWS::Lambda::Permission
    Condition: ServiceVFL
    Properties:
      FunctionName: !Ref LambdaVFL
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt ScheduledRuleLambdaVFL.Arn

  CyngularLambdaUpdateBucketPolicy:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: cyngular-lambda-update-cyngular-bucket
      Description: Created by Cyngular Security.
      Role: !GetAtt LambdasRole.Arn
      Environment:
        Variables:
          BUCKET_NAME: !Ref CyngularS3Bucket

      Runtime: "python3.12"
      Handler: index.cyngular_function
      Timeout: 300
      Code:
        ZipFile: | 
            import boto3
            import traceback
            import os
            import logging
            import json

            def get_account_ids_lst(management_account_id):
                child_accounts = []
                try:
                    org_client = boto3.client('organizations')
                    paginator = org_client.get_paginator('list_accounts')

                    for page in paginator.paginate():
                        child_accounts.extend(
                            account['Id'] for account in page['Accounts'] if account['Id'] != management_account_id
                        )                
                except Exception as e:
                    logging.critical("CloudServiceFunctions (ERROR) - while trying to get account ids for organization: " + str(e))
                return child_accounts

            def update_bucket(bucket_name, management_account_id):
                try:
                    s3_client=boto3.client('s3')
                    response=s3_client.get_bucket_policy(
                        Bucket=bucket_name
                    )
                    
                    account_ids_list=get_account_ids_lst(management_account_id)
                    account_arns_list=[]
                    for account_id in account_ids_list:
                        account_arns_list.append(f"\"arn:aws:logs:*:{account_id}:*\"")
                    new_statement = '''[
                        {
                            "Sid": "OrgLogDeliveryWrite",
                            "Effect": "Allow",
                            "Principal": {
                                "Service": "delivery.logs.amazonaws.com"
                            },
                            "Action": "s3:PutObject",
                            "Resource": "$%BUCKET_ARN%$/*",
                            "Condition": {
                                "ArnLike": {
                                    "AWS:SourceArn": [$%ACCOUNT_ARNS_LIST%$]
                                }
                            }
                        },
                        {
                            "Sid": "OrgLogDeliveryAclCheck",
                            "Effect": "Allow",
                            "Principal": {
                                "Service": "delivery.logs.amazonaws.com"
                            },
                            "Action": [
                                "s3:GetBucketAcl",
                                "s3:ListBucket"
                            ],
                            "Resource": "$%BUCKET_ARN%$",
                            "Condition": {
                                "ArnLike": {
                                    "aws:SourceArn": [$%ACCOUNT_ARNS_LIST%$]
                                }
                            }
                        }
                    ]
                    '''.replace('$%ACCOUNT_ARNS_LIST%$', ','.join(account_arns_list)).replace('$%BUCKET_ARN%$', f"arn:aws:s3:::{bucket_name}")
                    new_statement_json=json.loads(new_statement)
                    reponse_policy=json.loads(response['Policy'])
                    statement_policy=reponse_policy['Statement']
                    statement_policy.extend(new_statement_json)
                    new_policy = {}
                    new_policy['Statement']=statement_policy
                    new_policy['Version']='2012-10-17'

                    response=s3_client.put_bucket_policy(
                        Bucket=bucket_name,
                        Policy=json.dumps(new_policy)
                    )
                    logging.info(response)
                except Exception as e:
                    logging.critical(str(e))
                
            def cyngular_function(event, context):
                logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                logger.info('STARTING CYNGULAR\'S FUNCTION...')
                try:
                    logger.info('UPDATING CYNGULAR BUCKET POLICY')
                    cyngular_bucket_name = os.environ['BUCKET_NAME']
                    mgmt_acc_id = boto3.client('sts').get_caller_identity()['Account']

                    update_bucket(cyngular_bucket_name, mgmt_acc_id)
                    logger.info('DONE!')

                except Exception as e:
                    logger.critical(str(e))

  ManagerLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "cyngular-manager-lambda-role-${ClientName}"
      MaxSessionDuration: 43200

      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "lambda.amazonaws.com"
            Action: sts:AssumeRole
      Policies:
        - PolicyName: "CloudFormationPolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: InvokeBucketPolicyLambda
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
                  - lambda:GetFunction
                Resource:
                  - !GetAtt CyngularLambdaUpdateBucketPolicy.Arn

              - Sid: StackSetManager
                Effect: Allow
                Action:
                  - cloudformation:GetTemplateSummary
                  - cloudformation:ListStackSetOperationResults
                  - cloudformation:DescribeStacks
                  - cloudformation:DescribeStackSet
                  - cloudformation:DescribeStackSetOperation
                  - cloudformation:CreateStack
                  - cloudformation:CreateStackSet
                  - cloudformation:CreateStackInstances
                  - cloudformation:DeleteStackSet
                  - cloudformation:DeleteStackInstances
                Resource: "*"

              - Sid: OrgManager
                Effect: Allow
                Action: 
                  - organizations:ListAccounts
                  - organizations:ListRoots
                Resource: "*"

              - Sid: LogsManager
                Effect: Allow
                Action: logs:*
                Resource: "arn:aws:logs:*:*:*"

              - Sid: IdentityManager
                Effect: Allow
                Resource: "*"
                Action:
                  - sts:GetCallerIdentity
                  - iam:GetRole
                  - iam:getRolePolicy
                  - iam:PutRolePolicy
                  - iam:DetachRolePolicy
                  - iam:AttachRolePolicy
                  - iam:DeleteRolePolicy

              - Sid: GetStackSetTemplates
                Effect: "Allow"
                Resource:
                  - "arn:aws:s3:::cyngular-onboarding-templates/*"
                Action:
                  - "s3:GetObject"

  StackSetManagerTrigger:
    DependsOn: [AdminAndExecTrigger]
    Type: Custom::StackSetManager
    Version: "1.0"
    Properties:
      ServiceToken: !GetAtt LambdaStackSetManager.Arn
      ServiceTimeout: 1800
      Stack2URL: !Sub "https://cyngular-onboarding-templates.s3.amazonaws.com/stacks/stack2.yaml"
      StackSet1URL: !Sub "https://cyngular-onboarding-templates.s3.amazonaws.com/stacks/stackset_child1.yaml"
      StackSet2URL: !Sub "https://cyngular-onboarding-templates.s3.amazonaws.com/stacks/stackset_child2.yaml"

  LambdaStackSetManager:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "cyngular-lambda-stackset-manager"
      Description: "Created by Cyngular Security."
      Role: !GetAtt ManagerLambdaRole.Arn

      Runtime: python3.12
      Handler: index.cyngular_function
      Timeout: 600
      Environment:
        Variables:
          ClientName: !Ref ClientName
          ClientRegions: !Join [",", !Ref ClientRegions]

          UpdateBucketPolicyLambdaName: !Ref CyngularLambdaUpdateBucketPolicy

          CyngularAccountId: !Ref CyngularAccountId
          S3BucketArn: !GetAtt CyngularS3Bucket.Arn

          EnableDNS: !Ref EnableDNS
          EnableEKS: !Ref EnableEKS
          EnableVPCFlowLogs: !Ref EnableVPCFlowLogs
      Code:
        ZipFile: |
            import boto3
            import time
            import os
            import cfnresponse
            import logging

            def is_organization_account():
                try:
                    org_client = boto3.client('organizations')
                    root_response = org_client.list_roots()
                    if 'Roots' in root_response and len(root_response['Roots']) > 0:
                        return True, root_response['Roots'][0]['Id']
                except Exception as e:
                    print(f"Error checking organization status: {e}")
                return False, None

            def create_stack2(mgmt_acc_id, regions, url):
                cfn_client = boto3.client('cloudformation')
                cfn_client.create_stack_set(
                    StackSetName='cyngular-stackset-mgmt-regional',
                    Description='Cyngular Deployments | MGMT Account, Regional scope',
                    TemplateURL=url,
                    PermissionModel='SELF_MANAGED',
                    Capabilities=['CAPABILITY_IAM','CAPABILITY_NAMED_IAM'],
                    Parameters = [
                        {
                            'ParameterKey': 'CyngularAccountId',
                            'ParameterValue': os.environ['CyngularAccountId']
                        },
                        {
                            'ParameterKey': 'S3BucketArn',
                            'ParameterValue': os.environ['S3BucketArn']
                        },
                        {
                            'ParameterKey': 'EnableDNS',
                            'ParameterValue': os.environ['EnableDNS']
                        }
                    ]
                )
                cfn_client.create_stack_instances(
                    StackSetName = 'cyngular-stackset-mgmt-regional',
                    DeploymentTargets = {
                        "Accounts": [mgmt_acc_id]
                    },
                    Regions = regions,
                    OperationPreferences = {
                        'RegionConcurrencyType': 'PARALLEL',
                        'FailureTolerancePercentage': 0,
                        'MaxConcurrentPercentage': 100
                    }
                )
            def create_stackset1(deployment_targets, regions, url):
                cfn_client = boto3.client('cloudformation')
                cfn_client.create_stack_set(
                    StackSetName='cyngular-stackset-1',
                    Description='Cyngular Deployments | Child Accounts, Global scope',
                    TemplateURL=url,
                    PermissionModel='SERVICE_MANAGED',
                    AutoDeployment={
                        'Enabled': True,
                        'RetainStacksOnAccountRemoval': False
                    },
                    Capabilities=['CAPABILITY_IAM','CAPABILITY_NAMED_IAM'],
                    Parameters = [
                        {
                            'ParameterKey': 'ClientName',
                            'ParameterValue': os.environ['ClientName']
                        },
                        {
                            'ParameterKey': 'CyngularAccountId',
                            'ParameterValue': os.environ['CyngularAccountId']
                        },
                        {
                            'ParameterKey': 'S3BucketArn',
                            'ParameterValue': os.environ['S3BucketArn']
                        },
                        {
                            'ParameterKey': 'ClientRegions',
                            'ParameterValue': ','.join(regions)
                        },
                        {
                            'ParameterKey': 'EnableDNS',
                            'ParameterValue': (os.environ['EnableDNS'])
                        },
                        {
                            'ParameterKey': 'EnableEKS',
                            'ParameterValue': (os.environ['EnableEKS'])
                        },
                        {
                            'ParameterKey': 'EnableVPCFlowLogs',
                            'ParameterValue': (os.environ['EnableVPCFlowLogs'])
                        }
                    ]
                )
                cfn_client.create_stack_instances(
                    StackSetName = 'cyngular-stackset-1',
                    DeploymentTargets = deployment_targets,
                    Regions = [regions[0]],
                    OperationPreferences = {
                        'RegionConcurrencyType': 'PARALLEL',
                        'FailureTolerancePercentage': 0,
                        'MaxConcurrentPercentage': 100
                    }
                )
            def create_stackset2(deployment_targets, regions, url):
                cfn_client = boto3.client('cloudformation')
                cfn_client.create_stack_set(
                    StackSetName='cyngular-stackset-2',
                    Description='Cyngular Deployments | Child Accounts, Regional scope',
                    TemplateURL=url,
                    PermissionModel='SERVICE_MANAGED',
                    AutoDeployment={
                        'Enabled': True,
                        'RetainStacksOnAccountRemoval': False
                    },
                    Capabilities=['CAPABILITY_IAM','CAPABILITY_NAMED_IAM'],
                    Parameters=[
                        {
                            'ParameterKey': 'CyngularAccountId',
                            'ParameterValue': os.environ['CyngularAccountId']
                        },
                        {
                            'ParameterKey': 'S3BucketArn',
                            'ParameterValue': os.environ['S3BucketArn']
                        },
                        {
                            'ParameterKey': 'EnableDNS',
                            'ParameterValue': os.environ['EnableDNS']
                        }
                    ]
                )
                cfn_client.create_stack_instances(
                    StackSetName = 'cyngular-stackset-2',
                    DeploymentTargets = deployment_targets,
                    Regions = regions,
                    OperationPreferences = {
                        'RegionConcurrencyType': 'PARALLEL',
                        'FailureTolerancePercentage': 0,
                        'MaxConcurrentPercentage': 100
                    }
                )

            def invoke_lambda(func_name):
                try:
                    lambda_client = boto3.client('lambda')
                    response = lambda_client.invoke(
                        FunctionName = func_name,
                        InvocationType = 'RequestResponse',
                        LogType = 'Tail'
                    )
                    logging.info('lmbada E invoked!')
                    if response['StatusCode'] != 200:
                        logging.critical(f"Error {response}")
                except Exception as e:
                    logging.critical(str(e))

            def cyngular_function(event, context):
                try:
                    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
                    logger = logging.getLogger()
                    logger.setLevel(logging.INFO)
                    logging.info('STARTING CYNGULAR\'S FUNCTION...')

                    if event['RequestType'] == 'Create':
                        try:                            
                            mgmt_acc_id = boto3.client('sts').get_caller_identity()['Account']

                            is_org, root_id = is_organization_account()
                            deployment_targets = {'OrganizationalUnitIds': [root_id]} if is_org else {'Accounts': [mgmt_acc_id]}
                            regions = list(set(os.getenv('ClientRegions', '').split(',')))
                            logger.info(f"deploy targets -> {deployment_targets}")

                            stack2_url = event['ResourceProperties']['Stack2URL']
                            stackset1_url = event['ResourceProperties']['StackSet1URL']
                            stackset2_url = event['ResourceProperties']['StackSet2URL']
                            lambda_E_name = os.environ['UpdateBucketPolicyLambdaName']

                            logging.info("Updating Bucket Policy")
                            invoke_lambda(lambda_E_name)
                            time.sleep(60)
                            logging.info("STARING CYNGULAR STACK2")
                            create_stack2(mgmt_acc_id, regions, stack2_url)

                            if is_org:
                                logging.info("STARING CYNGULAR STACKSET1")
                                create_stackset1(deployment_targets, regions, stackset1_url)

                                logging.info("STARING CYNGULAR STACKSET2")
                                create_stackset2(deployment_targets, regions, stackset2_url)
                            logging.info("DONE WITH ALL CYNGULAR STACKS!")
                            cfnresponse.send(event, context, cfnresponse.SUCCESS, {'msg' : 'Done'})

                        except Exception as e:
                            logging.critical(str(e))
                            cfnresponse.send(event, context, cfnresponse.FAILED, {'msg' : str(e)})
                    else:
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {'msg' : 'No error'})
                except Exception as e:
                    logging.critical(str(e))
                    cfnresponse.send(event, context, cfnresponse.FAILED, {'msg' : str(e)})